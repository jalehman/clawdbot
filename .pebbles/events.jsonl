{"type":"create","timestamp":"2026-02-12T07:16:41.755939Z","issue_id":"openclaw-c3a","payload":{"description":"Goal: Extract OpenClaw context management behind a pluggable core abstraction while preserving current behavior.\n\nScope:\n- Define a neutral, OpenClaw-native context execution contract (no LCM-specific APIs in core).\n- Route runtime context execution through that contract:\n  - ingest\n  - assemble\n  - compact\n- Re-implement current behavior via a legacy/default engine implementation using the new abstraction.\n- Keep existing compaction UX/event contracts intact (/compact behavior, auto-compaction signaling, compaction counters).\n\nNon-goals:\n- No mandatory retrieval/lineage semantics in core interface.\n- No behavior changes for users unless explicitly behind config/feature selection.\n\nAcceptance criteria:\n1) Existing context behavior is preserved when default engine is selected.\n2) Existing tests remain in place and passing.\n3) New tests are added for abstraction boundaries and engine selection behavior.\n4) A plugin-capable selection path exists for alternate context engines.","priority":"1","title":"Core: pluggable context management abstraction + legacy reimplementation","type":"epic"}}
{"type":"create","timestamp":"2026-02-12T07:17:23.945116Z","issue_id":"openclaw-db0","payload":{"description":"Define ContextEngine core contract and selection model.\n\nDeliverables:\n- New core interface for execution path only: ingest/assemble/compact.\n- Engine registry/selection mechanism with default legacy engine.\n- Config surface for selecting active context engine (feature-flagged/slot-based as appropriate).\n\nAcceptance criteria:\n- Contract is neutral (no lineage/retrieval required methods).\n- Selection defaults to legacy behavior.\n- Unit tests cover selection/fallback behavior.","priority":"1","title":"Core: define ContextEngine interface + engine selection","type":"task"}}
{"type":"create","timestamp":"2026-02-12T07:17:23.966928Z","issue_id":"openclaw-885","payload":{"description":"Rewire run loop and compaction entry points to go through ContextEngine.\n\nTarget call sites include current direct compaction/assembly paths in embedded runner and /compact command flow.\n\nAcceptance criteria:\n- No direct compaction orchestration in call sites bypassing engine.\n- Existing user-visible behavior remains equivalent with legacy engine.\n- Existing tests continue passing; add focused regression tests for rewired paths.","priority":"1","title":"Core: route runtime context paths through ContextEngine","type":"task"}}
{"type":"create","timestamp":"2026-02-12T07:17:23.98845Z","issue_id":"openclaw-6b8","payload":{"description":"Implement LegacyContextEngine that reproduces current OpenClaw context/compaction behavior using the new contract.\n\nAcceptance criteria:\n- Legacy engine output/parity validated against existing tests.\n- Compaction event semantics and counters remain compatible.","priority":"1","title":"Core: implement LegacyContextEngine parity adapter","type":"task"}}
{"type":"create","timestamp":"2026-02-12T07:17:24.011301Z","issue_id":"openclaw-b39","payload":{"description":"Expose context engine plugin integration path.\n\nDeliverables:\n- Plugin registration surface for providing a ContextEngine implementation.\n- Safe startup/validation behavior when plugin engine missing or invalid.\n- Diagnostics/fallback to legacy engine.\n\nAcceptance criteria:\n- Alternate engine can be loaded without patching call sites.\n- Failure modes are explicit and recoverable.","priority":"1","title":"Plugins: add context-engine registration + safe fallback","type":"task"}}
{"type":"create","timestamp":"2026-02-12T07:17:24.034452Z","issue_id":"openclaw-629","payload":{"description":"Testing and migration hardening for pluggable context architecture.\n\nDeliverables:\n- Preserve existing test coverage and ensure it remains passing.\n- Add abstraction-focused tests (engine contract, default selection, fallback, parity checkpoints).\n- Add migration notes for maintainers.\n\nAcceptance criteria:\n- CI-equivalent test suite remains green.\n- New tests prevent regressions in engine selection/parity.","priority":"1","title":"Quality: preserve coverage and add pluggable-context regression tests","type":"task"}}
{"type":"rename","timestamp":"2026-02-12T07:17:24.055591Z","issue_id":"openclaw-db0","payload":{"new_id":"openclaw-c3a.1"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.055591Z","issue_id":"openclaw-c3a.1","payload":{"dep_type":"parent-child","depends_on":"openclaw-c3a"}}
{"type":"rename","timestamp":"2026-02-12T07:17:24.077365Z","issue_id":"openclaw-885","payload":{"new_id":"openclaw-c3a.2"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.077365Z","issue_id":"openclaw-c3a.2","payload":{"dep_type":"parent-child","depends_on":"openclaw-c3a"}}
{"type":"rename","timestamp":"2026-02-12T07:17:24.097698Z","issue_id":"openclaw-6b8","payload":{"new_id":"openclaw-c3a.3"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.097698Z","issue_id":"openclaw-c3a.3","payload":{"dep_type":"parent-child","depends_on":"openclaw-c3a"}}
{"type":"rename","timestamp":"2026-02-12T07:17:24.119085Z","issue_id":"openclaw-b39","payload":{"new_id":"openclaw-c3a.4"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.119085Z","issue_id":"openclaw-c3a.4","payload":{"dep_type":"parent-child","depends_on":"openclaw-c3a"}}
{"type":"rename","timestamp":"2026-02-12T07:17:24.14131Z","issue_id":"openclaw-629","payload":{"new_id":"openclaw-c3a.5"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.14131Z","issue_id":"openclaw-c3a.5","payload":{"dep_type":"parent-child","depends_on":"openclaw-c3a"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.164769Z","issue_id":"openclaw-c3a","payload":{"dep_type":"blocks","depends_on":"openclaw-c3a.1"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.18773Z","issue_id":"openclaw-c3a","payload":{"dep_type":"blocks","depends_on":"openclaw-c3a.2"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.214692Z","issue_id":"openclaw-c3a","payload":{"dep_type":"blocks","depends_on":"openclaw-c3a.3"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.238924Z","issue_id":"openclaw-c3a","payload":{"dep_type":"blocks","depends_on":"openclaw-c3a.4"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.261882Z","issue_id":"openclaw-c3a","payload":{"dep_type":"blocks","depends_on":"openclaw-c3a.5"}}
{"type":"create","timestamp":"2026-02-12T07:17:24.287108Z","issue_id":"openclaw-79e","payload":{"description":"Goal: Implement Lossless Context Management (LCM) as a plugin-backed context engine on top of the new pluggable context system.\n\nScope:\n- Implement LCM ingestion/assembly/compaction in plugin engine form.\n- Implement retrieval/introspection surfaces (describe/grep/expand) outside core engine contract.\n- Implement subagent expansion strategy:\n  - main agent routes via describe/grep\n  - subagent performs bounded deep expand traversal\n  - main agent receives distilled findings\n- Enforce secure cross-session expansion authorization.\n- Evaluate sqlite-first implementation in place of embedded postgres when practical.\n\nAcceptance criteria:\n1) LCM runs as selectable context engine plugin.\n2) Expansion strategy with subagents is implemented and tested.\n3) Security controls prevent unauthorized cross-session expansion.\n4) Storage decision documented with sqlite-first feasibility and tradeoffs.\n5) Existing OpenClaw tests remain passing; new LCM tests added.","priority":"1","title":"LCM plugin: implement lossless context engine + subagent expansion","type":"epic"}}
{"type":"create","timestamp":"2026-02-12T07:17:24.31491Z","issue_id":"openclaw-7bd","payload":{"description":"Decide and implement LCM storage backend with sqlite-first option.\n\nDeliverables:\n- Technical decision record: sqlite vs embedded postgres for v1 in OpenClaw plugin context.\n- If sqlite chosen: schema + migration strategy + concurrency approach.\n- If sqlite insufficient for requirements, document constraints and fallback path.\n\nAcceptance criteria:\n- Decision includes operational tradeoffs (locking, indexing, deploy complexity).\n- Chosen backend implemented for local development path.","priority":"1","title":"LCM: storage backend decision + implementation (sqlite-first evaluation)","type":"task"}}
{"type":"create","timestamp":"2026-02-12T07:17:24.344521Z","issue_id":"openclaw-d79","payload":{"description":"Implement LCM ConversationStore + ingestion pipeline in plugin engine.\n\nDeliverables:\n- Canonical message/part persistence.\n- Summary/lineage/context-item persistence primitives.\n- Idempotent ingest behavior and ordering guarantees.\n\nAcceptance criteria:\n- Canonical data is append-first and non-destructive.\n- Invariants validated with tests.","priority":"1","title":"LCM: implement canonical ingestion + conversation store","type":"task"}}
{"type":"create","timestamp":"2026-02-12T07:17:24.376026Z","issue_id":"openclaw-204","payload":{"description":"Implement LCM ContextAssembler + CompactionEngine in plugin engine.\n\nDeliverables:\n- Budget-aware assemble behavior.\n- Leaf + condensed compaction passes.\n- Safety rules (fresh tail protection, non-destructive compaction, ordering invariants).\n\nAcceptance criteria:\n- Compaction measurably reduces active context on fixtures.\n- Concurrent compaction safety covered by tests.","priority":"1","title":"LCM: implement assemble + compaction engine","type":"task"}}
{"type":"create","timestamp":"2026-02-12T07:17:24.40898Z","issue_id":"openclaw-01a","payload":{"description":"Expose LCM retrieval/introspection surfaces as plugin-owned adapters (not core engine API).\n\nDeliverables:\n- describe/grep/expand via plugin tools and/or gateway methods.\n- Bounded traversal controls (depth, token caps).\n- Clear separation of summary-id expansion vs file-id handling.\n\nAcceptance criteria:\n- Retrieval works without extending core ContextEngine contract.\n- Adapter layer remains thin (no ownership of core lineage rules).","priority":"1","title":"LCM: add plugin retrieval adapters (describe/grep/expand)","type":"task"}}
{"type":"create","timestamp":"2026-02-12T07:17:24.440399Z","issue_id":"openclaw-681","payload":{"description":"Implement LCM subagent expansion workflow aligned with strategy docs.\n\nDeliverables:\n- Main-agent routing pass to identify candidate IDs.\n- Subagent deep expansion passes with explicit bounds (depth/token cap).\n- Distilled return payloads with cited IDs for iterative follow-up.\n- Control over subagent model selection for expansion runs.\n\nAcceptance criteria:\n- Multi-hop expansion avoids flooding top-level context.\n- Iterative passes are auditable via cited IDs.","priority":"1","title":"LCM: implement subagent-driven expansion orchestration","type":"task"}}
{"type":"create","timestamp":"2026-02-12T07:17:24.472416Z","issue_id":"openclaw-0f1","payload":{"description":"Add secure cross-session expansion handoff and authorization controls.\n\nSecurity concerns to address:\n- Child subagent must not expand arbitrary IDs outside authorized scope.\n- Expansion permissions must be bound to explicit conversation/session scope.\n- Enforce depth/token/ID bounds from main-agent handoff.\n\nDeliverables:\n- Scoped expansion grant model (or equivalent authorization mechanism).\n- Validation in retrieval endpoints before expansion execution.\n- Negative tests for unauthorized cross-session access.\n\nAcceptance criteria:\n- Unauthorized expansion attempts are rejected.\n- Only explicitly delegated scopes can be traversed by subagents.","priority":"1","title":"LCM: secure cross-session expansion authorization","type":"task"}}
{"type":"create","timestamp":"2026-02-12T07:17:24.5125Z","issue_id":"openclaw-542","payload":{"description":"Implement LCM integrity checker and observability.\n\nDeliverables:\n- Integrity scan/report and repair-plan generation.\n- Metrics/logging for context tokens, compaction runs, expand/search latency, integrity failures.\n\nAcceptance criteria:\n- Integrity failures are detectable and actionable.\n- Operational metrics available for verification.","priority":"2","title":"LCM: integrity checker + observability","type":"task"}}
{"type":"create","timestamp":"2026-02-12T07:17:24.543818Z","issue_id":"openclaw-1b8","payload":{"description":"End-to-end test coverage for LCM plugin on pluggable context engine.\n\nDeliverables:\n- Integration tests: ingest -\u003e assemble -\u003e compact -\u003e retrieve/expand.\n- Subagent expansion tests (routing vs deep traversal separation).\n- Backward compatibility tests with legacy/default engine still passing.\n\nAcceptance criteria:\n- Existing OpenClaw test coverage remains passing and preserved.\n- New tests cover LCM-specific behaviors and security constraints.","priority":"1","title":"LCM: end-to-end and regression test suite","type":"task"}}
{"type":"rename","timestamp":"2026-02-12T07:17:24.574782Z","issue_id":"openclaw-7bd","payload":{"new_id":"openclaw-79e.1"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.574782Z","issue_id":"openclaw-79e.1","payload":{"dep_type":"parent-child","depends_on":"openclaw-79e"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.602943Z","issue_id":"openclaw-79e","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.1"}}
{"type":"rename","timestamp":"2026-02-12T07:17:24.629334Z","issue_id":"openclaw-d79","payload":{"new_id":"openclaw-79e.2"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.629334Z","issue_id":"openclaw-79e.2","payload":{"dep_type":"parent-child","depends_on":"openclaw-79e"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.657638Z","issue_id":"openclaw-79e","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.2"}}
{"type":"rename","timestamp":"2026-02-12T07:17:24.684856Z","issue_id":"openclaw-204","payload":{"new_id":"openclaw-79e.3"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.684856Z","issue_id":"openclaw-79e.3","payload":{"dep_type":"parent-child","depends_on":"openclaw-79e"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.715239Z","issue_id":"openclaw-79e","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.3"}}
{"type":"rename","timestamp":"2026-02-12T07:17:24.742516Z","issue_id":"openclaw-01a","payload":{"new_id":"openclaw-79e.4"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.742516Z","issue_id":"openclaw-79e.4","payload":{"dep_type":"parent-child","depends_on":"openclaw-79e"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.772836Z","issue_id":"openclaw-79e","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.4"}}
{"type":"rename","timestamp":"2026-02-12T07:17:24.802302Z","issue_id":"openclaw-681","payload":{"new_id":"openclaw-79e.5"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.802302Z","issue_id":"openclaw-79e.5","payload":{"dep_type":"parent-child","depends_on":"openclaw-79e"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.836004Z","issue_id":"openclaw-79e","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.5"}}
{"type":"rename","timestamp":"2026-02-12T07:17:24.8664Z","issue_id":"openclaw-0f1","payload":{"new_id":"openclaw-79e.6"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.8664Z","issue_id":"openclaw-79e.6","payload":{"dep_type":"parent-child","depends_on":"openclaw-79e"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.899334Z","issue_id":"openclaw-79e","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.6"}}
{"type":"rename","timestamp":"2026-02-12T07:17:24.932524Z","issue_id":"openclaw-542","payload":{"new_id":"openclaw-79e.7"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.932524Z","issue_id":"openclaw-79e.7","payload":{"dep_type":"parent-child","depends_on":"openclaw-79e"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:24.969892Z","issue_id":"openclaw-79e","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.7"}}
{"type":"rename","timestamp":"2026-02-12T07:17:25.003932Z","issue_id":"openclaw-1b8","payload":{"new_id":"openclaw-79e.8"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:25.003932Z","issue_id":"openclaw-79e.8","payload":{"dep_type":"parent-child","depends_on":"openclaw-79e"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:25.037866Z","issue_id":"openclaw-79e","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.8"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:25.07398Z","issue_id":"openclaw-79e","payload":{"dep_type":"blocks","depends_on":"openclaw-c3a"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:44.841864Z","issue_id":"openclaw-c3a.2","payload":{"dep_type":"blocks","depends_on":"openclaw-c3a.1"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:44.876569Z","issue_id":"openclaw-c3a.3","payload":{"dep_type":"blocks","depends_on":"openclaw-c3a.1"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:44.910422Z","issue_id":"openclaw-c3a.4","payload":{"dep_type":"blocks","depends_on":"openclaw-c3a.1"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:44.944981Z","issue_id":"openclaw-c3a.5","payload":{"dep_type":"blocks","depends_on":"openclaw-c3a.2"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:44.980259Z","issue_id":"openclaw-c3a.5","payload":{"dep_type":"blocks","depends_on":"openclaw-c3a.3"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:45.0151Z","issue_id":"openclaw-c3a.5","payload":{"dep_type":"blocks","depends_on":"openclaw-c3a.4"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:45.050115Z","issue_id":"openclaw-79e.2","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.1"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:45.085417Z","issue_id":"openclaw-79e.3","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.2"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:45.12172Z","issue_id":"openclaw-79e.4","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.2"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:45.164279Z","issue_id":"openclaw-79e.5","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.4"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:45.200988Z","issue_id":"openclaw-79e.6","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.4"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:45.237713Z","issue_id":"openclaw-79e.6","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.5"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:45.276651Z","issue_id":"openclaw-79e.7","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.2"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:45.313573Z","issue_id":"openclaw-79e.7","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.3"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:45.351045Z","issue_id":"openclaw-79e.8","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.3"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:45.389985Z","issue_id":"openclaw-79e.8","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.4"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:45.427707Z","issue_id":"openclaw-79e.8","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.5"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:45.467507Z","issue_id":"openclaw-79e.8","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.6"}}
{"type":"dep_add","timestamp":"2026-02-12T07:17:45.507475Z","issue_id":"openclaw-79e.8","payload":{"dep_type":"blocks","depends_on":"openclaw-79e.7"}}
{"type":"update","timestamp":"2026-02-12T07:21:31.369469Z","issue_id":"openclaw-c3a","payload":{"description":"Goal: Extract OpenClaw context management behind a pluggable core abstraction while preserving current behavior.\n\nCurrent implementation context (must be understood before edits):\n- Context assembly and message replacement are currently wired inside `src/agents/pi-embedded-runner/run/attempt.ts`.\n- Auto-compaction orchestration is currently wired inside `src/agents/pi-embedded-runner/run.ts`.\n- Manual compaction path is wired through `src/agents/pi-embedded-runner/compact.ts` and `/compact` handling in `src/auto-reply/reply/commands-compact.ts`.\n- Plugin system exists (`src/plugins/*`), but there is no first-class context-engine registration path yet.\n\nScope:\n- Define a neutral, OpenClaw-native context execution contract (no LCM-specific semantics in required core methods).\n- Route runtime context execution through that contract:\n  - ingest\n  - assemble\n  - compact\n- Re-implement current behavior via a legacy/default engine implementation using the new abstraction.\n- Keep existing compaction UX/event contracts intact:\n  - stream events from `src/agents/pi-embedded-subscribe.handlers.lifecycle.ts`\n  - session compaction counts and status behavior used in auto-reply/session updates\n\nNon-goals:\n- No mandatory retrieval/lineage/expand APIs in the required core interface.\n- No user-visible behavior regressions unless explicitly behind selection config.\n\nAcceptance criteria:\n1) Existing behavior is preserved with default legacy engine selected.\n2) Existing tests remain in place and passing.\n3) New tests are added for abstraction boundaries and engine selection/fallback.\n4) A plugin-capable selection path exists for alternate context engines."}}
{"type":"update","timestamp":"2026-02-12T07:21:31.415693Z","issue_id":"openclaw-c3a.1","payload":{"description":"Define `ContextEngine` core contract and selection model.\n\nImplementation context:\n- Current plugin slot system is defined in `src/plugins/slots.ts` and `src/plugins/config-state.ts` (today only memory slot exists).\n- Plugin API/registration plumbing is in `src/plugins/types.ts`, `src/plugins/registry.ts`, and `src/plugins/loader.ts`.\n\nDeliverables:\n- New core execution contract with required methods only: ingest/assemble/compact.\n- Engine registry/selection mechanism with default legacy engine.\n- Config surface for selecting active context engine (slot or equivalent), including schema and validation wiring.\n\nConstraints:\n- Required core contract must remain neutral and not require retrieval/lineage methods.\n- Selection must default to legacy behavior when unset/invalid.\n\nAcceptance criteria:\n- Contract is neutral (no lineage/retrieval required methods).\n- Selection defaults to legacy behavior.\n- Unit tests cover selection, invalid selection, and fallback behavior."}}
{"type":"update","timestamp":"2026-02-12T07:21:31.461266Z","issue_id":"openclaw-c3a.2","payload":{"description":"Rewire runtime context paths to call `ContextEngine` instead of direct inline orchestration.\n\nPrimary callsites to rewire:\n- `src/agents/pi-embedded-runner/run/attempt.ts` (context assembly path before prompt)\n- `src/agents/pi-embedded-runner/run.ts` (overflow-triggered auto-compaction/retry path)\n- `src/agents/pi-embedded-runner/compact.ts` (manual/direct compaction path)\n- `src/auto-reply/reply/commands-compact.ts` (/compact command path)\n\nBehavioral constraints:\n- Do not break compaction stream event semantics used by lifecycle handlers.\n- Preserve session compaction count and status integration.\n- Preserve current error handling/retry semantics for overflow + compaction failure paths.\n\nAcceptance criteria:\n- No direct compaction orchestration in these callsites bypassing engine contract.\n- Existing user-visible behavior remains equivalent with legacy engine.\n- Existing tests continue passing; add regression tests for rewired call paths."}}
{"type":"update","timestamp":"2026-02-12T07:21:31.5093Z","issue_id":"openclaw-c3a.3","payload":{"description":"Implement `LegacyContextEngine` that reproduces current OpenClaw behavior via the new interface.\n\nImplementation context:\n- Legacy compaction/summarization helpers currently live in `src/agents/compaction.ts`.\n- Embedded runner history sanitization/truncation logic is in `src/agents/pi-embedded-runner/run/attempt.ts` and `src/agents/pi-embedded-runner/compact.ts`.\n\nDeliverables:\n- Legacy adapter that preserves current ingest/assemble/compact outcomes.\n- Adapter behavior parity for compaction summaries, token estimates, and retry expectations.\n\nAcceptance criteria:\n- Parity validated against existing tests.\n- Compaction event and counter semantics remain compatible.\n- No behavior regression for `/compact`, overflow auto-compaction, and follow-up status surfaces."}}
{"type":"update","timestamp":"2026-02-12T07:21:31.55566Z","issue_id":"openclaw-c3a.4","payload":{"description":"Add plugin registration path for pluggable context engines with safe startup behavior.\n\nImplementation context:\n- Plugin registration points: `src/plugins/types.ts`, `src/plugins/registry.ts`, `src/plugins/loader.ts`.\n- Existing plugin runtime/tool resolution: `src/plugins/tools.ts`, `src/agents/openclaw-tools.ts`.\n\nDeliverables:\n- Plugin API surface that allows a plugin to provide a `ContextEngine` implementation.\n- Startup validation and diagnostics for missing/invalid engine implementations.\n- Deterministic fallback to legacy engine when plugin engine cannot load.\n\nConstraints:\n- Keep plugin registration additive; do not break existing plugin APIs.\n- Failure modes must be explicit in diagnostics/logging.\n\nAcceptance criteria:\n- Alternate engine can be selected and loaded without touching runtime callsites.\n- Invalid/missing plugin engine falls back safely to legacy engine.\n- Tests cover registration, selection, and fallback diagnostics."}}
{"type":"update","timestamp":"2026-02-12T07:21:31.604473Z","issue_id":"openclaw-c3a.5","payload":{"description":"Testing and migration hardening for pluggable context architecture.\n\nImplementation context:\n- Existing compaction/runner coverage includes tests under `src/agents/*compaction*.test.ts` and overflow/embedded runner tests (including `run.overflow-compaction` coverage).\n- Session/status flows depend on compaction counters and lifecycle behavior.\n\nDeliverables:\n- Preserve existing coverage and passing tests (do not remove current tests).\n- Add abstraction-focused tests:\n  - engine contract behavior\n  - default engine selection\n  - invalid engine fallback\n  - legacy parity checkpoints\n- Add migration notes for maintainers implementing future engines.\n\nAcceptance criteria:\n- CI-equivalent suite remains green.\n- New tests prevent regressions in engine selection and parity.\n- Migration notes explain how to add a new engine safely."}}
{"type":"update","timestamp":"2026-02-12T07:21:31.650785Z","issue_id":"openclaw-79e","payload":{"description":"Goal: Implement Lossless Context Management (LCM) as a plugin-backed context engine on top of the pluggable context system from `openclaw-c3a`.\n\nPrerequisite:\n- `openclaw-c3a` must land first (LCM epic depends on it).\n\nScope:\n- Implement LCM ingestion/assembly/compaction in plugin engine form.\n- Keep retrieval/introspection adapters (`describe/grep/expand`) outside required core engine methods.\n- Implement subagent expansion strategy from updated LCM docs:\n  - main agent routes via describe/grep to target IDs\n  - subagent performs bounded deep expand traversal\n  - main agent receives distilled findings and cited IDs\n- Enforce secure cross-session expansion authorization.\n- Evaluate sqlite-first backend vs embedded postgres.\n\nCritical OpenClaw integration context:\n- Subagent spawning/model override path is in `src/agents/tools/sessions-spawn-tool.ts`.\n- Subagent announce/return flow is in `src/agents/subagent-announce.ts`.\n- Existing session scoping/filtering (`spawnedBy`) behavior is in `src/gateway/sessions-resolve.ts` and `src/gateway/session-utils.ts`.\n\nAcceptance criteria:\n1) LCM runs as selectable context engine plugin.\n2) Subagent expansion strategy is implemented and tested.\n3) Security controls prevent unauthorized cross-session expansion.\n4) Storage decision documented with sqlite-first feasibility and tradeoffs.\n5) Existing OpenClaw tests remain passing; new LCM tests added."}}
{"type":"update","timestamp":"2026-02-12T07:21:31.698386Z","issue_id":"openclaw-79e.1","payload":{"description":"Decide and implement LCM storage backend with sqlite-first evaluation.\n\nRequired decision context:\n- LCM spec currently describes PostgreSQL schema/locking semantics.\n- OpenClaw/plugin deployment ergonomics may favor sqlite for local/in-process operation.\n\nDeliverables:\n- Technical decision record comparing sqlite vs embedded postgres for v1.\n- If sqlite chosen: schema design, migration approach, and concurrency/locking strategy.\n- If sqlite cannot meet requirements, document exact blockers and define fallback plan.\n\nEvaluation criteria to include:\n- transaction semantics for lineage writes\n- lock contention/retry behavior\n- indexing/search feasibility for grep/full-text\n- operational complexity in typical OpenClaw installs\n\nAcceptance criteria:\n- Decision and rationale are explicit and reproducible.\n- Chosen backend implemented for local dev path."}}
{"type":"update","timestamp":"2026-02-12T07:21:31.745169Z","issue_id":"openclaw-79e.2","payload":{"description":"Implement LCM `ConversationStore` + ingestion pipeline in plugin engine.\n\nImplementation context:\n- Ingestion must capture canonical data for messages/tool results/file artifacts.\n- OpenClaw transcript/tool lifecycle touchpoints include session manager and tool-result persistence paths in `src/agents/session-tool-result-guard-wrapper.ts` and embedded runner flows.\n\nDeliverables:\n- Canonical message/part persistence.\n- Summary/lineage/context-item persistence primitives.\n- Idempotent ingest behavior and deterministic ordering guarantees.\n\nConstraints:\n- Canonical layer is append-first and non-destructive.\n- No data-loss on write path.\n\nAcceptance criteria:\n- Invariants validated with tests.\n- Canonical persistence supports downstream assemble/compact/retrieval flows."}}
{"type":"update","timestamp":"2026-02-12T07:21:31.792244Z","issue_id":"openclaw-79e.3","payload":{"description":"Implement LCM `ContextAssembler` + `CompactionEngine` in plugin engine.\n\nImplementation context:\n- This task is the plugin implementation behind core engine contract methods.\n- It must integrate with rewired runtime callsites from `openclaw-c3a` without bespoke branching.\n\nDeliverables:\n- Budget-aware context assembly.\n- Leaf and condensed compaction passes.\n- Safety rules: fresh-tail protection, non-destructive compaction, ordering invariants.\n\nConstraints:\n- Preserve OpenClaw runtime expectations for compaction outcomes and retry behavior.\n- Ensure concurrent compaction safety and no partial lineage states.\n\nAcceptance criteria:\n- Compaction reduces active context on fixture conversations.\n- Concurrent safety covered by tests."}}
{"type":"update","timestamp":"2026-02-12T07:21:31.840613Z","issue_id":"openclaw-79e.4","payload":{"description":"Expose LCM retrieval/introspection as plugin-owned adapters (not required core engine methods).\n\nImplementation context:\n- Plugin tools can be registered via `api.registerTool` (`src/plugins/types.ts`, `src/plugins/tools.ts`).\n- Plugin gateway methods can be registered via `api.registerGatewayMethod` (`src/plugins/registry.ts`).\n\nDeliverables:\n- `describe`/`grep`/`expand` adapters via plugin tools and/or gateway methods.\n- Bounded traversal controls (depth, token cap, limits).\n- Explicit split between summary-id expansion and file-id handling.\n\nConstraints:\n- Adapter layer must not own compaction/lineage core rules.\n- Retrieval APIs must be auditable and bounded.\n\nAcceptance criteria:\n- Retrieval works without extending required core `ContextEngine` contract.\n- Adapter behavior is validated by tests."}}
{"type":"update","timestamp":"2026-02-12T07:21:31.889827Z","issue_id":"openclaw-79e.5","payload":{"description":"Implement subagent-driven LCM expansion orchestration per updated strategy.\n\nImplementation context:\n- Subagent spawning is implemented by `sessions_spawn` in `src/agents/tools/sessions-spawn-tool.ts`.\n- Child model can be explicitly controlled via spawn `model` parameter and defaults.\n- Subagent return/announcement behavior is managed in `src/agents/subagent-announce.ts`.\n\nDeliverables:\n- Main-agent routing pass to identify candidate IDs via describe/grep.\n- Subagent deep expansion passes with explicit depth/token bounds.\n- Distilled return payloads with cited IDs for iterative follow-up.\n- Deterministic control over subagent model selection for expansion runs.\n\nConstraints:\n- Avoid flooding top-level context with raw expansion payloads.\n- Preserve auditability via cited IDs for follow-up traversal.\n\nAcceptance criteria:\n- Multi-hop traversal is delegated to subagents, not main-agent prompt bloat.\n- Iterative pass behavior is covered by tests."}}
{"type":"update","timestamp":"2026-02-12T07:21:31.942772Z","issue_id":"openclaw-79e.6","payload":{"description":"Add secure cross-session expansion handoff and authorization controls.\n\nImplementation context:\n- Cross-session resolution and spawned-session scoping behavior exists in:\n  - `src/gateway/sessions-resolve.ts`\n  - `src/gateway/session-utils.ts`\n- LCM retrieval endpoints/tools must enforce equivalent or stronger scope checks.\n\nSecurity concerns to address:\n- Child subagent must not expand arbitrary IDs outside delegated scope.\n- Expansion permissions must bind to explicit conversation/session scope.\n- Enforce main-agent handoff bounds (IDs/depth/token caps/expiry).\n\nDeliverables:\n- Scoped expansion grant model (or equivalent authorization mechanism).\n- Validation in retrieval endpoints/tools before expansion execution.\n- Negative tests for unauthorized cross-session access and out-of-scope IDs.\n\nAcceptance criteria:\n- Unauthorized expansion attempts are rejected.\n- Only explicitly delegated scopes can be traversed by subagents."}}
{"type":"update","timestamp":"2026-02-12T07:21:31.994627Z","issue_id":"openclaw-79e.7","payload":{"description":"Implement LCM integrity checker and observability.\n\nImplementation context:\n- LCM requires lineage/integrity invariants and operational metrics.\n- Plugin background workers/services can be hosted through plugin service registration.\n\nDeliverables:\n- Integrity scan/report and repair-plan generation.\n- Metrics/logging for:\n  - context tokens\n  - compaction runs/summaries\n  - expand/search latency\n  - integrity failures\n\nAcceptance criteria:\n- Integrity failures are detectable and actionable.\n- Operational metrics/logs are available to validate steady-state health."}}
{"type":"update","timestamp":"2026-02-12T07:21:32.04607Z","issue_id":"openclaw-79e.8","payload":{"description":"Create end-to-end and regression coverage for LCM plugin on pluggable context engine.\n\nImplementation context:\n- Existing OpenClaw compaction and runner coverage must remain in place.\n- New LCM paths must be tested alongside legacy engine compatibility.\n\nDeliverables:\n- Integration tests for ingest -\u003e assemble -\u003e compact -\u003e retrieve/expand.\n- Subagent expansion tests verifying routing vs deep traversal separation.\n- Security regression tests for cross-session authorization constraints.\n- Backward compatibility tests ensuring legacy/default engine behavior still passes.\n\nAcceptance criteria:\n- Existing test coverage remains passing and preserved.\n- New tests cover LCM behavior, subagent strategy, and security controls."}}
{"type":"dep_add","timestamp":"2026-02-12T19:30:08.604734Z","issue_id":"openclaw-79e","payload":{"dep_type":"blocks","depends_on":"openclaw-c3a"}}
{"type":"close","timestamp":"2026-02-12T19:41:06.627105Z","issue_id":"openclaw-c3a.1","payload":{}}
{"type":"status_update","timestamp":"2026-02-12T19:42:01.877042Z","issue_id":"openclaw-c3a.2","payload":{"status":"in_progress"}}
{"type":"status_update","timestamp":"2026-02-12T19:42:04.995852Z","issue_id":"openclaw-c3a.4","payload":{"status":"in_progress"}}
{"type":"status_update","timestamp":"2026-02-12T19:43:11.621641Z","issue_id":"openclaw-c3a.3","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-12T19:47:30.53085Z","issue_id":"openclaw-c3a.3","payload":{}}
{"type":"close","timestamp":"2026-02-12T19:47:36.695617Z","issue_id":"openclaw-c3a.3","payload":{}}
{"type":"close","timestamp":"2026-02-12T19:51:08.902201Z","issue_id":"openclaw-c3a.4","payload":{}}
{"type":"close","timestamp":"2026-02-12T19:51:31.8048Z","issue_id":"openclaw-c3a.2","payload":{}}
{"type":"status_update","timestamp":"2026-02-12T20:23:31.447187Z","issue_id":"openclaw-c3a.5","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-12T20:29:00.055792Z","issue_id":"openclaw-c3a.5","payload":{}}
{"type":"close","timestamp":"2026-02-12T20:32:28.148738Z","issue_id":"openclaw-c3a","payload":{}}
{"type":"status_update","timestamp":"2026-02-12T22:07:18.024649Z","issue_id":"openclaw-79e.1","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-12T22:12:07.242364Z","issue_id":"openclaw-79e.1","payload":{}}
{"type":"status_update","timestamp":"2026-02-12T22:52:39.370306Z","issue_id":"openclaw-79e.4","payload":{"status":"in_progress"}}
{"type":"status_update","timestamp":"2026-02-12T22:52:58.257714Z","issue_id":"openclaw-79e.2","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-12T23:07:10.788222Z","issue_id":"openclaw-79e.4","payload":{}}
{"type":"close","timestamp":"2026-02-12T23:08:22.117492Z","issue_id":"openclaw-79e.2","payload":{}}
{"type":"close","timestamp":"2026-02-13T00:52:34.511949Z","issue_id":"openclaw-79e.3","payload":{}}
{"type":"close","timestamp":"2026-02-13T00:52:34.573078Z","issue_id":"openclaw-79e.5","payload":{}}
{"type":"status_update","timestamp":"2026-02-13T01:07:48.223364Z","issue_id":"openclaw-79e.6","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-13T01:08:07.667517Z","issue_id":"openclaw-79e.6","payload":{}}
{"type":"close","timestamp":"2026-02-13T01:10:01.246015Z","issue_id":"openclaw-79e.7","payload":{}}
{"type":"close","timestamp":"2026-02-13T01:41:12.045221Z","issue_id":"openclaw-79e.6","payload":{}}
{"type":"close","timestamp":"2026-02-13T01:41:12.109685Z","issue_id":"openclaw-79e.7","payload":{}}
{"type":"close","timestamp":"2026-02-13T01:49:27.172877Z","issue_id":"openclaw-79e.8","payload":{}}
{"type":"close","timestamp":"2026-02-13T02:03:17.785061Z","issue_id":"openclaw-79e.8","payload":{}}
{"type":"create","timestamp":"2026-02-13T19:29:40.339159Z","issue_id":"openclaw-4d5","payload":{"description":"Complete the openclaw-c3a scope by wiring the remaining two ContextEngine methods (ingest and assemble) into the message pipeline. Currently only compact() is called at runtime. Per the LCM spec, the foreground path should be: ingest -\u003e store -\u003e assemble -\u003e model call. The legacy engine's no-op/pass-through implementations ensure zero behavior change for non-LCM users.","priority":"1","title":"Wire ContextEngine.ingest() and ContextEngine.assemble() into runtime pipeline","type":"epic"}}
{"type":"create","timestamp":"2026-02-13T19:29:46.936082Z","issue_id":"openclaw-548","payload":{"description":"Add ContextEngine to EmbeddedRunAttemptParams (run/types.ts). Resolve the engine once in run.ts before the retry loop using ensureContextEnginesInitialized() + resolveContextEngine(params.config). Pass it into runEmbeddedAttempt. Replace the inline resolveContextEngine call in the overflow compact block (run.ts:540-541) with the pre-resolved instance. Add contextEngine.dispose?.() in the finally block (run.ts:906). Files: src/agents/pi-embedded-runner/run/types.ts, src/agents/pi-embedded-runner/run.ts","priority":"1","title":"Add contextEngine param and resolve once per run","type":"task"}}
{"type":"create","timestamp":"2026-02-13T19:29:49.45537Z","issue_id":"openclaw-f41","payload":{"description":"In attempt.ts, after the sanitize/validate/truncate/repair pipeline (after line 577 replaceMessages(limited)), call contextEngine.assemble() if params.contextEngine is set. Use reference equality to skip replaceMessages for legacy pass-through. Wrap in try/catch — fall back to pipeline messages on failure. Legacy engine returns messages as-is (zero cost). LCM engine builds context from its canonical store. File: src/agents/pi-embedded-runner/run/attempt.ts","priority":"1","title":"Wire ContextEngine.assemble() into attempt pipeline","type":"task"}}
{"type":"create","timestamp":"2026-02-13T19:29:51.993398Z","issue_id":"openclaw-b2b","payload":{"description":"In attempt.ts, capture prePromptMessageCount before the prompt call (before line 826). After messagesSnapshot is captured (after line 867), iterate over messagesSnapshot.slice(prePromptMessageCount) and call contextEngine.ingest() for each new message. Wrap each call in try/catch with log.warn — ingest failures must not break the primary pipeline. Legacy engine is a no-op. LCM engine persists to SQLite. File: src/agents/pi-embedded-runner/run/attempt.ts","priority":"1","title":"Wire ContextEngine.ingest() into attempt pipeline","type":"task"}}
{"type":"dep_add","timestamp":"2026-02-13T19:32:29.565967Z","issue_id":"openclaw-4d5","payload":{"dep_type":"blocks","depends_on":"openclaw-548"}}
{"type":"dep_add","timestamp":"2026-02-13T19:32:29.626694Z","issue_id":"openclaw-4d5","payload":{"dep_type":"blocks","depends_on":"openclaw-f41"}}
{"type":"dep_add","timestamp":"2026-02-13T19:32:29.713318Z","issue_id":"openclaw-4d5","payload":{"dep_type":"blocks","depends_on":"openclaw-b2b"}}
{"type":"dep_add","timestamp":"2026-02-13T19:32:29.794557Z","issue_id":"openclaw-f41","payload":{"dep_type":"blocks","depends_on":"openclaw-548"}}
{"type":"dep_add","timestamp":"2026-02-13T19:32:29.854949Z","issue_id":"openclaw-b2b","payload":{"dep_type":"blocks","depends_on":"openclaw-548"}}
{"type":"create","timestamp":"2026-02-13T20:44:44.690132Z","issue_id":"openclaw-7c4","payload":{"description":"## Bug\n\n`LcmContextEngine.ingest()` in `src/plugins/lcm/engine.ts:106-113` calls `JSON.stringify(message.content)` when content is an array of content blocks (e.g. `[{type:\"text\", text:\"HEARTBEAT_OK\"}]`). This stores the raw JSON string in the DB.\n\nWhen the assembler later reconstructs messages from the DB, the model sees literal JSON like `[{\"type\":\"text\",\"text\":\"HEARTBEAT_OK\"}]` as its own prior output and starts pattern-matching on it — producing corrupted responses that echo raw JSON content block syntax.\n\n## Root Cause\n\nThe content extraction in `ingest()` has a branch for non-string content that blindly JSON.stringify's it:\n\n```typescript\nconst content =\n  \"content\" in message\n    ? typeof message.content === \"string\"\n      ? message.content\n      : JSON.stringify(message.content)  // ← this line\n    : ...\n```\n\nAgentMessage `.content` is frequently an array of content blocks like `[{type: \"text\", text: \"...\"}, {type: \"thinking\", ...}]`. The text should be extracted, not serialized.\n\n## Fix\n\nReplace the `JSON.stringify` branch with content block extraction:\n\n```typescript\n: Array.isArray(message.content)\n  ? (message.content as { type?: string; text?: string }[])\n      .filter((b) =\u003e b.type === \"text\" \u0026\u0026 typeof b.text === \"string\")\n      .map((b) =\u003e b.text)\n      .join(\"\\n\")\n  : JSON.stringify(message.content)\n```\n\nKeep `JSON.stringify` as final fallback for unexpected shapes.\n\n## Files\n\n- `src/plugins/lcm/engine.ts` — fix content extraction in `ingest()` method\n\n## Tests Required\n\nAdd tests in the LCM test suite that verify:\n1. String content is stored as-is\n2. Content block arrays `[{type:\"text\", text:\"hello\"}]` are flattened to `\"hello\"`\n3. Mixed content blocks (text + thinking + tool_use) extract only text blocks\n4. Empty arrays produce empty string\n5. Non-array non-string content falls back to JSON.stringify\n6. Roundtrip: ingest a message with content blocks, then verify the stored DB content is plain text (not JSON)","priority":"0","title":"LCM ingest corrupts content block arrays via JSON.stringify","type":"bug"}}
{"type":"create","timestamp":"2026-02-13T20:45:03.868404Z","issue_id":"openclaw-4d9","payload":{"description":"## Bug\n\n`LcmContextEngine.assemble()` in `src/plugins/lcm/engine.ts:146-176` replaces the full live session messages with messages built from the LCM SQLite DB. But the DB only contains messages ingested post-prompt — it is missing:\n\n- System prompts\n- Pre-prompt context (initial instructions, boot messages, session history loaded from file)\n- User messages (added during `prompt()`, after ingest's `prePromptMessageCount` marker is set)\n- Internal compaction summaries from pi-coding-agent\n\nThis means from turn 2 onward, `assemble()` replaces the full context with a near-empty DB copy, causing total context amnesia. The model loses all awareness of prior conversation.\n\n## Observed Impact\n\n- Agent had zero awareness of immediately preceding messages\n- `/status` showed \"Tokens: 4 in / 158 out\" after context was wiped\n- Agent merged a PR to wrong branch because it couldn't remember instructions from previous turn\n\n## Root Cause\n\n`assemble()` unconditionally builds from DB when a conversation exists:\n\n```typescript\nconst conversation = await this.conversationStore.getConversationBySessionId(sessionId);\nif (!conversation) {\n  return { messages: params.messages, estimatedTokens: 0 };  // pass-through\n}\n// Builds entirely from DB, ignores params.messages\nconst result = await this.assembler.assemble({ conversationId, tokenBudget, freshTailCount });\nreturn { messages: result.messages, ... };\n```\n\nThe reference check in attempt.ts `assembled.messages !== activeSession.messages` is always true (different object), so `replaceMessages()` always fires.\n\n## Fix\n\nMake `assemble()` pass-through until LCM has full conversation coverage. Return `params.messages` unchanged:\n\n```typescript\nasync assemble(params: { sessionId: string; messages: AgentMessage[]; tokenBudget?: number }): Promise\u003cAssembleResult\u003e {\n  // Pass-through: LCM does not yet have full conversation coverage.\n  // System prompts, pre-prompt context, and internal compaction summaries\n  // are not captured by ingest (which only runs post-prompt). Replacing\n  // live session messages with the incomplete DB contents on every turn\n  // causes total context amnesia.\n  //\n  // Ingest continues to populate the DB for compaction and retrieval.\n  return { messages: params.messages, estimatedTokens: 0 };\n}\n```\n\n## Files\n\n- `src/plugins/lcm/engine.ts` — make `assemble()` pass-through\n\n## Tests Required\n\nAdd tests that verify:\n1. `assemble()` returns the same messages array reference that was passed in (identity check)\n2. `assemble()` does not modify or reorder the input messages\n3. `assemble()` works even when a conversation exists in the DB (still passes through)\n4. After ingest + assemble roundtrip, the live messages are unchanged\n5. The DB is still populated by ingest (assemble being pass-through doesn't break ingest)","priority":"0","title":"LCM assemble() replaces live session messages with incomplete DB, causing context amnesia","type":"bug"}}
{"type":"dep_add","timestamp":"2026-02-13T20:45:09.953063Z","issue_id":"openclaw-4d5","payload":{"dep_type":"blocks","depends_on":"openclaw-7c4"}}
{"type":"dep_add","timestamp":"2026-02-13T20:45:10.003756Z","issue_id":"openclaw-4d5","payload":{"dep_type":"blocks","depends_on":"openclaw-4d9"}}
{"type":"status_update","timestamp":"2026-02-13T20:46:04.507774Z","issue_id":"openclaw-4d9","payload":{"status":"in_progress"}}
{"type":"status_update","timestamp":"2026-02-13T20:46:09.794259Z","issue_id":"openclaw-7c4","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-13T20:48:25.375152Z","issue_id":"openclaw-4d9","payload":{}}
{"type":"close","timestamp":"2026-02-13T20:49:02.646975Z","issue_id":"openclaw-7c4","payload":{}}
{"type":"create","timestamp":"2026-02-13T21:04:39.93228Z","issue_id":"openclaw-ea5","payload":{"description":"Make LCM the sole context manager when contextEngine=lcm. Currently LCM is a passive observer — it ingests post-prompt messages but never replaces live session context. This epic covers the full path to active context management:\n\n1. Bootstrap existing session history into LCM DB on first activation\n2. Capture all messages (system prompts, user messages) during ingest\n3. Wire real LLM-powered summarization for compaction\n4. Add threshold-based proactive compaction triggers\n5. Disable pi-coding-agent's internal auto-compaction when LCM is active\n6. Re-enable assemble() to build context from the canonical LCM store\n\nSpec document: /tmp/lcm-active-context-manager-spec.md\n\nParent epic: openclaw-79e (LCM plugin)\nDepends on: openclaw-7c4 (ingest content fix) and openclaw-4d9 (assemble pass-through fix)","priority":"1","title":"LCM Active Context Manager — replace pi-coding-agent context lifecycle","type":"epic"}}
{"type":"create","timestamp":"2026-02-13T21:04:49.412142Z","issue_id":"openclaw-512","payload":{"description":"When LCM is enabled on an existing session, the DB is empty — no history from before activation. On the first ingest/assemble call for a session with no conversation in the DB, read the session JSONL file and bulk-ingest its messages.\n\n## How session files work\n\npi-coding-agent's SessionManager.open(sessionFile) parses JSONL where each line is a JSON object with id, parentId, timestamp, type fields. Entry types: message, compaction, thinking_level_change, model_change, etc. Message entries have role + content in AgentMessage shape. Compaction entries contain summary text that replaced earlier messages.\n\n## Implementation\n\n- Add a bootstrap(params: { sessionId, sessionFile }) method to LcmContextEngine\n- Call from attempt.ts before the first assemble() call, passing the session file path\n- Parse JSONL, filter to message-type entries, map to AgentMessage format\n- Bulk-ingest into conversation store\n- Track bootstrap state (e.g. bootstrapped flag in conversations table) so it runs once per session\n- Handle compaction entries: ingest as summary records, not raw messages\n- Add bootstrap to ContextEngine interface as optional method\n\n## Files\n\n- src/plugins/lcm/engine.ts — add bootstrap() method\n- src/plugins/lcm/store/conversation-store.ts — bulk insert support\n- src/agents/pi-embedded-runner/run/attempt.ts — call bootstrap before assemble\n- src/context-engine/types.ts — add optional bootstrap to interface\n\n## Caveats\n\n- JSONL format is internal to pi-coding-agent — keep parser isolated\n- Session file path already available in attempt pipeline (sessionFile param)\n- Large sessions may take time to bootstrap — consider async/progress","priority":"1","title":"Bootstrap existing session JSONL into LCM DB on first activation","type":"task"}}
{"type":"create","timestamp":"2026-02-13T21:04:58.540121Z","issue_id":"openclaw-623","payload":{"description":"Current ingest only captures messagesSnapshot.slice(prePromptMessageCount) — post-prompt new messages. It misses system prompts (set via agent.setSystemPrompt(), not part of message array) and potentially user messages.\n\n## How system prompts work\n\nAgentSession.prompt() calls agent.setSystemPrompt(baseOrModifiedPrompt) before agent.prompt(messages). The system prompt is NOT part of the messages array. Extensions can modify it via before_agent_start hook.\n\n## How user messages work\n\nThe user message is built inside AgentSession.prompt() and passed as part of the messages array to agent.prompt(messages). Need to verify whether pi-coding-agent appends these to the session's message list (making them visible in activeSession.messages post-prompt) — if so, the current ingest slice captures them. If not, we have a gap.\n\n## Implementation\n\n- System prompts: ingest as role=\"system\" message at conversation start, track hash to detect changes and re-ingest only when modified\n- User messages: verify current path captures them. If not, explicitly ingest before prompt call\n- DB schema already supports MessageRole = \"user\" | \"assistant\" | \"system\" | \"tool\"\n- Consider dedup logic for system prompts (same content shouldn't create duplicate entries)\n\n## Files\n\n- src/plugins/lcm/engine.ts — add system prompt ingestion\n- src/agents/pi-embedded-runner/run/attempt.ts — wire system prompt capture\n- src/plugins/lcm/store/conversation-store.ts — dedup logic for system prompts","priority":"1","title":"Full ingest coverage — capture system prompts and user messages","type":"task"}}
{"type":"create","timestamp":"2026-02-13T21:05:06.656042Z","issue_id":"openclaw-3fc","payload":{"description":"LcmContextEngine.compact() uses a placeholder summarizer (createDefaultSummarize in engine.ts) that just truncates text to ~3600 chars. Real compaction requires LLM-powered summarization.\n\n## Current state\n\n- compact() accepts a summarize callback via legacyParams.summarize\n- If not provided, falls back to createDefaultSummarize() which truncates\n- The /compact command path passes legacyParams with provider/model info but no summarize callback\n- Summarize signature: (text: string, aggressive?: boolean) =\u003e Promise\u003cstring\u003e\n\n## Implementation\n\n- Create summarization prompt templates (normal: preserve key details; aggressive: distill to essentials)\n- Wire the configured LLM provider into the summarize callback using provider/model from legacyParams\n- Ensure provider info flows through from both /compact and overflow-retry compact paths\n- Consider token budget for the summarization call itself\n\n## Files\n\n- src/plugins/lcm/engine.ts — wire real summarizer using provider from legacyParams\n- src/plugins/lcm/summarize.ts — new file for prompt templates and provider call\n- src/agents/pi-embedded-runner/run.ts — ensure provider info flows through","priority":"1","title":"Wire LLM-powered summarization into LCM compaction","type":"task"}}
{"type":"create","timestamp":"2026-02-13T21:05:14.238283Z","issue_id":"openclaw-e98","payload":{"description":"pi-coding-agent fires compaction proactively when context exceeds a threshold (checked pre-prompt and post-turn). LCM compact only runs on overflow retry and /compact. If we disable internal compaction, we lose proactive compaction.\n\n## How pi-coding-agent threshold works\n\n_checkCompaction() checks after each turn and before each prompt. Reads last assistant message usage.totalTokens, compares against context window. Two triggers: overflow (error-driven, retries) and threshold (proactive, no retry).\n\n## Implementation\n\n- After each ingest() call, evaluate conversation total tokens against threshold\n- If over LcmConfig.contextThreshold (default 0.75) of token budget, trigger compact()\n- Token budget comes from model context window (available via legacyParams or session config)\n- Should be post-ingest, non-blocking to the prompt response path\n- Consider: should this run after every ingest, or only after the full post-prompt ingest batch?\n\n## Files\n\n- src/plugins/lcm/engine.ts — add threshold evaluation after ingest\n- src/agents/pi-embedded-runner/run/attempt.ts — pass token budget, add post-ingest compaction check","priority":"1","title":"Add threshold-based proactive compaction trigger to LCM","type":"task"}}
{"type":"create","timestamp":"2026-02-13T21:05:21.705383Z","issue_id":"openclaw-b80","payload":{"description":"With LCM managing compaction, pi-coding-agent's internal auto-compaction creates a dual-path conflict. Both systems may try to compact, leading to inconsistent state.\n\n## Available API\n\n- agentSession.setAutoCompactionEnabled(false) — runtime toggle\n- settingsManager.setCompactionEnabled(false) — settings-level toggle\n- OpenClaw already overrides settings via SettingsManager before session creation (src/agents/pi-embedded-runner/run/attempt.ts:444-448, src/agents/pi-settings.ts:10-25)\n\n## Implementation\n\n- When contextEngine=lcm and LCM is fully ready (bootstrapped + real summarizer), set compaction.enabled=false in SettingsManager override\n- Use existing override point in src/agents/pi-settings.ts\n- LcmConfig.autocompactDisabled field already exists but isn't wired — use it\n- Guard: only disable when all prerequisites are met (bootstrap done, real summarizer wired, threshold trigger active)\n\n## Files\n\n- src/agents/pi-settings.ts — add compaction disable when contextEngine=lcm\n- src/agents/pi-embedded-runner/run/attempt.ts — pass context engine info to settings\n- src/config/types.agent-defaults.ts — may need config surface for toggle","priority":"1","title":"Disable pi-coding-agent internal auto-compaction when contextEngine=lcm","type":"task"}}
{"type":"create","timestamp":"2026-02-13T21:05:29.341938Z","issue_id":"openclaw-b68","payload":{"description":"Once tasks 1-5 are complete, remove the assemble() pass-through and restore DB-driven context assembly. This is the final switchover that makes LCM the active context manager.\n\n## Implementation\n\n- Remove the pass-through in assemble() and restore the ContextAssembler call\n- System prompts need special treatment — always included at start of assembled context\n- Fresh tail (recent N messages) always protected from eviction\n- Budget-aware: older messages/summaries evicted when over budget\n- Fallback guard: if DB is empty or bootstrap hasn't run, pass through unchanged\n- The reference check in attempt.ts (assembled.messages !== activeSession.messages) will naturally trigger replaceMessages()\n\n## Acceptance criteria\n\n- Assemble builds from DB including summaries from compaction\n- System prompt always present at start\n- Fresh tail protected\n- Budget-aware eviction of older items\n- Graceful fallback to pass-through when DB is incomplete\n\n## Files\n\n- src/plugins/lcm/engine.ts — restore assembler call with guards\n- src/plugins/lcm/assembler.ts — ensure system prompt handling","priority":"1","title":"Re-enable LCM assemble() to build context from canonical store","type":"task"}}
{"type":"dep_add","timestamp":"2026-02-13T21:05:57.268308Z","issue_id":"openclaw-ea5","payload":{"dep_type":"blocks","depends_on":"openclaw-512"}}
{"type":"dep_add","timestamp":"2026-02-13T21:05:57.325053Z","issue_id":"openclaw-ea5","payload":{"dep_type":"blocks","depends_on":"openclaw-623"}}
{"type":"dep_add","timestamp":"2026-02-13T21:05:57.388851Z","issue_id":"openclaw-ea5","payload":{"dep_type":"blocks","depends_on":"openclaw-3fc"}}
{"type":"dep_add","timestamp":"2026-02-13T21:05:57.446007Z","issue_id":"openclaw-ea5","payload":{"dep_type":"blocks","depends_on":"openclaw-e98"}}
{"type":"dep_add","timestamp":"2026-02-13T21:05:57.503328Z","issue_id":"openclaw-ea5","payload":{"dep_type":"blocks","depends_on":"openclaw-b80"}}
{"type":"dep_add","timestamp":"2026-02-13T21:05:57.560853Z","issue_id":"openclaw-ea5","payload":{"dep_type":"blocks","depends_on":"openclaw-b68"}}
{"type":"dep_add","timestamp":"2026-02-13T21:05:57.623138Z","issue_id":"openclaw-ea5","payload":{"dep_type":"blocks","depends_on":"openclaw-7c4"}}
{"type":"dep_add","timestamp":"2026-02-13T21:05:57.697365Z","issue_id":"openclaw-ea5","payload":{"dep_type":"blocks","depends_on":"openclaw-4d9"}}
{"type":"dep_add","timestamp":"2026-02-13T21:05:57.76621Z","issue_id":"openclaw-b80","payload":{"dep_type":"blocks","depends_on":"openclaw-512"}}
{"type":"dep_add","timestamp":"2026-02-13T21:05:57.862367Z","issue_id":"openclaw-b80","payload":{"dep_type":"blocks","depends_on":"openclaw-623"}}
{"type":"dep_add","timestamp":"2026-02-13T21:05:57.918948Z","issue_id":"openclaw-b80","payload":{"dep_type":"blocks","depends_on":"openclaw-3fc"}}
{"type":"dep_add","timestamp":"2026-02-13T21:05:57.983181Z","issue_id":"openclaw-b80","payload":{"dep_type":"blocks","depends_on":"openclaw-e98"}}
{"type":"dep_add","timestamp":"2026-02-13T21:05:58.035821Z","issue_id":"openclaw-b68","payload":{"dep_type":"blocks","depends_on":"openclaw-b80"}}
{"type":"rename","timestamp":"2026-02-13T21:05:58.089876Z","issue_id":"openclaw-ea5","payload":{"new_id":"openclaw-79e.9"}}
{"type":"dep_add","timestamp":"2026-02-13T21:05:58.089876Z","issue_id":"openclaw-79e.9","payload":{"dep_type":"parent-child","depends_on":"openclaw-79e"}}
{"type":"title_updated","timestamp":"2026-02-13T21:48:01.970289Z","issue_id":"openclaw-512","payload":{"title":"Bootstrap existing session context into LCM using SessionManager leaf-path semantics"}}
{"type":"update","timestamp":"2026-02-13T21:48:01.970289Z","issue_id":"openclaw-512","payload":{"description":"Source references:\n- Spec: `/tmp/lcm-active-context-manager-spec.md`\n- Review: `/tmp/lcm-plan-review.md`\n\nGoal\nBootstrap existing pi session history into LCM DB exactly once per session, using the same leaf-path semantics as runtime SessionManager context construction.\n\nWhy this revision\n- LCM currently has no bootstrap path (`src/plugins/lcm/engine.ts:125`) and `assemble()` is pass-through (`src/plugins/lcm/engine.ts:168`).\n- Raw JSONL parsing is insufficient: `parseSessionEntries()` only parses/skips malformed lines and does not perform migration/index semantics (`.../session-manager.js:78`, `.../session-manager.js:93`).\n- Runtime context is tree/leaf-path based (`buildSessionContext()` in `.../session-manager.js:107`, `.../session-manager.js:579`), so bootstrap must not ingest abandoned branches.\n- Current schema has no bootstrapped marker (`src/plugins/lcm/db/migration.ts:5`).\n- Store currently lacks bulk insert API (`src/plugins/lcm/store/conversation-store.ts:175`).\n- `prepareSessionManagerForRun()` may truncate files with no assistant entries (`src/agents/pi-embedded-runner/session-manager-init.ts:44`), so bootstrap ordering must avoid data loss.\n\nScope\n1. Add `bootstrap(params: { sessionId, sessionFile })` to `LcmContextEngine` (`src/plugins/lcm/engine.ts`) and optional `bootstrap` to `ContextEngine` interface (`src/context-engine/types.ts`) if needed.\n2. Build bootstrap input via SessionManager semantics (open/set session file + leaf-path context reconstruction), not raw append-order parse-only ingestion.\n3. Add schema migration for a bootstrapped state flag tied to conversation/session bootstrap lifecycle.\n4. Add bulk insert API in `ConversationStore` for efficient initial import.\n5. Wire bootstrap call in `src/agents/pi-embedded-runner/run/attempt.ts` before LCM assemble activation and before any truncation-prone init path.\n6. Include idempotency and duplicate protection so bootstrap is one-time per session.\n\nAcceptance criteria\n- First LCM activation on an existing session imports only the active leaf-path conversation, not abandoned branches.\n- Repeat activation does not duplicate imported messages.\n- Bootstrap state is persisted in DB and visible in code-level checks.\n- Bulk import path is used (not per-message loop only).\n- Ordering avoids `prepareSessionManagerForRun()` data-loss edge.\n\nImplementation pointers\n- `src/plugins/lcm/engine.ts`\n- `src/plugins/lcm/store/conversation-store.ts`\n- `src/plugins/lcm/db/migration.ts`\n- `src/agents/pi-embedded-runner/run/attempt.ts`\n- `src/agents/pi-embedded-runner/session-manager-init.ts`\n- `src/context-engine/types.ts`\n\nGlobal dependency order (revised)\n1. `openclaw-512` Bootstrap (this issue)\n2. `openclaw-623` Ingest coverage (revised)\n3. NEW fidelity/token-budget prerequisite issue\n4. `openclaw-3fc` Real summarizer\n5. `openclaw-b68` Enable assemble (depends on 512, 623, NEW, 3fc)\n6. `openclaw-e98` Threshold compaction (depends on b68)\n7. `openclaw-b80` Disable Pi auto-compaction (depends on b68, e98)"}}
{"type":"title_updated","timestamp":"2026-02-13T21:48:02.023933Z","issue_id":"openclaw-623","payload":{"title":"Ingest coverage revision: system-prompt policy + user-message verification"}}
{"type":"update","timestamp":"2026-02-13T21:48:02.023933Z","issue_id":"openclaw-623","payload":{"description":"Source references:\n- Spec: `/tmp/lcm-active-context-manager-spec.md`\n- Review: `/tmp/lcm-plan-review.md`\n\nGoal\nClose real ingest coverage gaps without duplicating behavior that already works.\n\nWhy this revision\n- System prompt gap is real: prompt is set via `setSystemPrompt` and is not in prompt message array (`src/agents/pi-embedded-runner/run/attempt.ts:496`, `.../agent-session.js:451`).\n- User-message gap is mostly not real: prompt messages are emitted/appended by agent loop and captured by post-prompt delta ingest (`.../agent-loop.js:20`, `.../agent-loop.js:23`, `.../agent.js:275`, `.../agent.js:279`, `src/agents/pi-embedded-runner/run/attempt.ts:753`, `src/agents/pi-embedded-runner/run/attempt.ts:909`).\n- Forcing system prompts into `role=system` DB messages conflicts with Pi runtime message model and can duplicate instructions if `setSystemPrompt` remains active (`.../pi-ai/dist/types.d.ts:86`, `.../pi-ai/dist/types.d.ts:111`, `src/plugins/lcm/assembler.ts:39`, `src/plugins/lcm/assembler.ts:44`).\n\nScope\n1. Keep existing user-message ingest behavior; add explicit verification/tests that current `messagesSnapshot.slice(prePromptMessageCount)` path captures user prompt messages in normal turns.\n2. Add explicit system prompt capture policy that is compatible with Pi runtime model:\n   - Track system prompt state/metadata in LCM without creating instruction-duplicating assembled messages.\n   - Ensure policy is compatible with extension-modified system prompts.\n3. Document and enforce boundary with fidelity issue:\n   - This issue does not solve full role-fidelity mapping for `toolResult` fallback (`src/plugins/lcm/engine.ts:59`, `src/plugins/lcm/engine.ts:67`); that is handled by the NEW prerequisite issue.\n\nAcceptance criteria\n- Tests/validation show user prompts are ingested from current delta path.\n- System prompt handling is defined and implemented without double-instruction behavior.\n- Behavior remains compatible with runtime `setSystemPrompt` flow.\n- No regressions in ingest for assistant/tool traffic.\n\nImplementation pointers\n- `src/agents/pi-embedded-runner/run/attempt.ts`\n- `src/plugins/lcm/engine.ts`\n- `src/plugins/lcm/assembler.ts`\n- Relevant tests for turn ingest behavior\n\nGlobal dependency order (revised)\n1. `openclaw-512` Bootstrap\n2. `openclaw-623` Ingest coverage (this issue)\n3. NEW fidelity/token-budget prerequisite issue\n4. `openclaw-3fc` Real summarizer\n5. `openclaw-b68` Enable assemble (depends on 512, 623, NEW, 3fc)\n6. `openclaw-e98` Threshold compaction (depends on b68)\n7. `openclaw-b80` Disable Pi auto-compaction (depends on b68, e98)"}}
{"type":"title_updated","timestamp":"2026-02-13T21:48:02.08034Z","issue_id":"openclaw-3fc","payload":{"title":"Wire model-backed LCM summarizer with correct token budget plumbing"}}
{"type":"update","timestamp":"2026-02-13T21:48:02.08034Z","issue_id":"openclaw-3fc","payload":{"description":"Source references:\n- Spec: `/tmp/lcm-active-context-manager-spec.md`\n- Review: `/tmp/lcm-plan-review.md`\n\nGoal\nReplace placeholder truncation summarizer with real model-backed summarization for LCM compaction.\n\nWhy this revision\n- Current fallback summarizer is truncation-only (`src/plugins/lcm/engine.ts:205`, `src/plugins/lcm/engine.ts:276`).\n- Provider/model are already passed in compact paths more than previously assumed (`src/agents/pi-embedded-runner/run.ts:548`, `src/agents/pi-embedded-runner/run.ts:560`, `src/auto-reply/reply/commands-compact.ts:101`, `src/auto-reply/reply/commands-compact.ts:114`).\n- LCM compact currently defaults token budget to `128000` when not provided (`src/plugins/lcm/engine.ts:211`), which is wrong for many models and must be corrected.\n\nScope\n1. Implement production summarizer module (e.g. `src/plugins/lcm/summarize.ts`) with normal/aggressive prompt policies.\n2. Wire summarizer into `LcmContextEngine.compact()` so fallback truncation is only emergency fallback.\n3. Ensure model/auth/runtime context is available where summarizer is invoked (inject callback or runtime wiring from run paths).\n4. Remove hard dependency on default `128000` behavior for normal flows; use resolved model context window/token budget plumbing.\n5. Keep `/compact` and overflow-triggered compact aligned with same summarizer path.\n\nAcceptance criteria\n- Compaction summaries are generated by model-backed summarizer in configured runtime.\n- Aggressive vs normal modes produce distinct summarization behavior.\n- Token budget behavior aligns with actual resolved model context and does not silently rely on 128000 default in regular path.\n- `/compact` and overflow compaction both use same summarizer integration.\n\nImplementation pointers\n- `src/plugins/lcm/engine.ts`\n- `src/plugins/lcm/summarize.ts` (new)\n- `src/agents/pi-embedded-runner/run.ts`\n- `src/auto-reply/reply/commands-compact.ts`\n\nGlobal dependency order (revised)\n1. `openclaw-512` Bootstrap\n2. `openclaw-623` Ingest coverage\n3. NEW fidelity/token-budget prerequisite issue\n4. `openclaw-3fc` Real summarizer (this issue)\n5. `openclaw-b68` Enable assemble (depends on 512, 623, NEW, 3fc)\n6. `openclaw-e98` Threshold compaction (depends on b68)\n7. `openclaw-b80` Disable Pi auto-compaction (depends on b68, e98)"}}
{"type":"title_updated","timestamp":"2026-02-13T21:48:02.141598Z","issue_id":"openclaw-e98","payload":{"title":"Add turn-batch threshold compaction with budget and concurrency control"}}
{"type":"update","timestamp":"2026-02-13T21:48:02.141598Z","issue_id":"openclaw-e98","payload":{"description":"Source references:\n- Spec: `/tmp/lcm-active-context-manager-spec.md`\n- Review: `/tmp/lcm-plan-review.md`\n\nGoal\nAdd proactive threshold-based compaction for active LCM context, with correct turn batching, token-budget usage, and concurrency control.\n\nWhy this revision\n- Pi has proactive pre/post checks (`.../agent-session.js:414`, `.../agent-session.js:996`), while LCM only compacts when explicitly called.\n- Threshold checks should run once per full turn ingest batch, not per individual message insert.\n- `assemble()` currently receives no token budget (`src/agents/pi-embedded-runner/run/attempt.ts:585`), so this task must use budget plumbing from prerequisites.\n- Current compaction termination mismatch: threshold decision logic vs `compactUntilUnder` exit criteria (`src/plugins/lcm/compaction.ts:84`, `src/plugins/lcm/compaction.ts:240`, `src/plugins/lcm/compaction.ts:252`).\n- Non-blocking trigger requires per-session serialization/lock to prevent ingest-compaction races.\n\nScope\n1. Trigger proactive threshold check once per turn after post-prompt ingest batch completes.\n2. Use resolved token budget/context window from plumbing path; do not rely on static defaults.\n3. Align threshold-trigger compaction target with threshold semantics (not only \u003c= full token budget).\n4. Add per-session concurrency guard/queue so ingest and proactive compact do not race or overlap dangerously.\n5. Keep overflow/manual compact behavior compatible.\n\nAcceptance criteria\n- Exactly one proactive threshold evaluation per completed turn ingest batch.\n- Threshold-triggered compaction uses correct budget and threshold ratio.\n- Compaction convergence target matches threshold policy.\n- Concurrent turn traffic does not cause duplicate/racing compaction runs.\n\nImplementation pointers\n- `src/plugins/lcm/engine.ts`\n- `src/plugins/lcm/compaction.ts`\n- `src/agents/pi-embedded-runner/run/attempt.ts`\n\nGlobal dependency order (revised)\n1. `openclaw-512` Bootstrap\n2. `openclaw-623` Ingest coverage\n3. NEW fidelity/token-budget prerequisite issue\n4. `openclaw-3fc` Real summarizer\n5. `openclaw-b68` Enable assemble\n6. `openclaw-e98` Threshold compaction (this issue; depends on b68)\n7. `openclaw-b80` Disable Pi auto-compaction (depends on b68, e98)"}}
{"type":"title_updated","timestamp":"2026-02-13T21:48:02.20141Z","issue_id":"openclaw-b80","payload":{"title":"Disable Pi auto-compaction only in feature-flagged LCM cutover"}}
{"type":"update","timestamp":"2026-02-13T21:48:02.20141Z","issue_id":"openclaw-b80","payload":{"description":"Source references:\n- Spec: `/tmp/lcm-active-context-manager-spec.md`\n- Review: `/tmp/lcm-plan-review.md`\n\nGoal\nDisable Pi internal auto-compaction only at the safe LCM switchover point, not earlier.\n\nWhy this revision\n- Dual compaction paths conflict once LCM is active.\n- Ordering is critical: disabling Pi auto-compaction before LCM assemble switchover can remove the only effective live compaction path while assemble is still pass-through (`src/plugins/lcm/engine.ts:168`, `src/agents/pi-embedded-runner/run/attempt.ts:589`).\n- Runtime gating can be done from existing context engine branching in attempt path (`src/agents/pi-embedded-runner/run/attempt.ts:583`) and settings manager API (`.../settings-manager.js:175`); this likely does not require `src/config/types.agent-defaults.ts` edits.\n- Existing `autocompactDisabled` config field is currently unwired (`src/plugins/lcm/db/config.ts:12`, `src/plugins/lcm/db/config.ts:25`).\n\nScope\n1. Implement disablement of Pi auto-compaction behind the same feature-flagged cutover that enables LCM assemble + proactive threshold compaction.\n2. Wire settings/runtime toggles (`setCompactionEnabled(false)` or equivalent) only when safe prerequisites are satisfied in runtime path.\n3. Ensure rollback/guard behavior: if LCM active-path prerequisites are not met, Pi auto-compaction remains enabled.\n4. Document and wire `autocompactDisabled` semantics if retained.\n\nAcceptance criteria\n- Pi auto-compaction remains enabled before LCM assemble cutover.\n- At feature-flag cutover, Pi auto-compaction is disabled and LCM path owns compaction.\n- No regression in overflow recovery during transition.\n\nImplementation pointers\n- `src/agents/pi-settings.ts`\n- `src/agents/pi-embedded-runner/run/attempt.ts`\n- `src/plugins/lcm/db/config.ts`\n- `.../settings-manager.js` API integration points\n\nGlobal dependency order (revised)\n1. `openclaw-512` Bootstrap\n2. `openclaw-623` Ingest coverage\n3. NEW fidelity/token-budget prerequisite issue\n4. `openclaw-3fc` Real summarizer\n5. `openclaw-b68` Enable assemble\n6. `openclaw-e98` Threshold compaction\n7. `openclaw-b80` Disable Pi auto-compaction (this issue; depends on b68 and e98)"}}
{"type":"title_updated","timestamp":"2026-02-13T21:48:02.254094Z","issue_id":"openclaw-b68","payload":{"title":"Enable LCM assemble as canonical context with fidelity + budget safeguards"}}
{"type":"update","timestamp":"2026-02-13T21:48:02.254094Z","issue_id":"openclaw-b68","payload":{"description":"Source references:\n- Spec: `/tmp/lcm-active-context-manager-spec.md`\n- Review: `/tmp/lcm-plan-review.md`\n\nGoal\nRe-enable LCM `assemble()` as canonical context source after prerequisites are complete, with robust fallback and correct budget/fidelity behavior.\n\nWhy this revision\n- Current `assemble()` remains pass-through (`src/plugins/lcm/engine.ts:168`).\n- Runtime call currently omits token budget (`src/agents/pi-embedded-runner/run/attempt.ts:585`).\n- Canonical switchover is unsafe without fidelity fixes because current ingest/assembly path is lossy:\n  - content extraction strips non-text structure (`src/plugins/lcm/engine.ts:31`),\n  - unknown roles collapse to user (`src/plugins/lcm/engine.ts:59`),\n  - assembler remaps roles (`system` -\u003e `user`, `tool` -\u003e `assistant`) (`src/plugins/lcm/assembler.ts:39`, `src/plugins/lcm/assembler.ts:46`).\n\nScope\n1. Replace pass-through with DB-backed assembly path in `LcmContextEngine.assemble()`.\n2. Ensure `attempt.ts` passes token budget/context window into assemble API.\n3. Integrate with prerequisite fidelity issue so structured message parts and role mapping are preserved sufficiently for canonical use.\n4. Keep robust fallback: if bootstrap incomplete/DB unavailable, return safe pass-through without breaking prompt path.\n5. Keep assembly behavior compatible with system prompt strategy from ingest scope (avoid duplicate instruction channels).\n\nAcceptance criteria\n- LCM assemble returns DB-assembled context in active mode.\n- Assembled context respects budget and fresh-tail rules with resolved token budget.\n- Canonical assembly path preserves role/content fidelity per prerequisite issue.\n- Prompt flow remains stable via guarded fallback when DB coverage is incomplete.\n\nImplementation pointers\n- `src/plugins/lcm/engine.ts`\n- `src/plugins/lcm/assembler.ts`\n- `src/agents/pi-embedded-runner/run/attempt.ts`\n- `src/plugins/lcm/db/migration.ts` / store APIs used by prerequisites\n\nGlobal dependency order (revised)\n1. `openclaw-512` Bootstrap\n2. `openclaw-623` Ingest coverage\n3. NEW fidelity/token-budget prerequisite issue\n4. `openclaw-3fc` Real summarizer\n5. `openclaw-b68` Enable assemble (this issue; depends on 512, 623, NEW, 3fc)\n6. `openclaw-e98` Threshold compaction (depends on b68)\n7. `openclaw-b80` Disable Pi auto-compaction (depends on b68, e98)"}}
{"type":"create","timestamp":"2026-02-13T21:48:02.312338Z","issue_id":"openclaw-c4c","payload":{"description":"Source references:\n- Spec: `/tmp/lcm-active-context-manager-spec.md`\n- Review: `/tmp/lcm-plan-review.md`\n\nGoal\nAdd prerequisite fidelity and token-budget plumbing needed before LCM assemble can safely become canonical.\n\nWhy this issue is required\n- Current ingest path is not lossless in active usage even though schema has `message_parts` (`src/plugins/lcm/db/migration.ts:34`): ingest flattens to text and drops non-text structure (`src/plugins/lcm/engine.ts:31`).\n- Role mapping is lossy:\n  - unknown roles (including `toolResult`) fall back to `user` in `toDbRole` (`src/plugins/lcm/engine.ts:59`, `src/plugins/lcm/engine.ts:67`),\n  - assembler rewrites DB roles (`system` -\u003e `user`, `tool` -\u003e `assistant`) (`src/plugins/lcm/assembler.ts:39`, `src/plugins/lcm/assembler.ts:46`).\n- Token budget is resolved in runtime model context (`src/agents/pi-embedded-runner/run.ts:218`) but not plumbed consistently into LCM assemble/compact (`src/agents/pi-embedded-runner/run/attempt.ts:585`, `src/plugins/lcm/engine.ts:211`).\n\nScope\n1. Preserve structured message parts on ingest/storage where supported (`message_parts`) instead of text-only flattening.\n2. Fix role mapping to preserve `toolResult`/tool semantics and avoid generic fallback-to-user behavior.\n3. Update assembler mapping to faithfully reconstruct runtime-compatible messages with robust fallback for unsupported roles.\n4. Plumb resolved token budget/context window through assemble and compact APIs so LCM decisions are model-correct.\n5. Add tests for fidelity round-trip (roles + structured parts) and token-budget flow into assemble/compact.\n\nAcceptance criteria\n- Non-text message content used by runtime is preserved in DB and reconstructed in assemble output (or explicitly transformed with tested fallback policy).\n- `toolResult`/tool-related roles do not silently become `user`.\n- assemble/compact receive model-derived token budget in normal run path.\n- Behavior is stable enough to unblock `openclaw-b68` canonical assemble switchover.\n\nImplementation pointers\n- `src/plugins/lcm/engine.ts`\n- `src/plugins/lcm/assembler.ts`\n- `src/plugins/lcm/db/migration.ts`\n- `src/plugins/lcm/store/conversation-store.ts`\n- `src/agents/pi-embedded-runner/run.ts`\n- `src/agents/pi-embedded-runner/run/attempt.ts`\n\nGlobal dependency order (revised)\n1. `openclaw-512` Bootstrap\n2. `openclaw-623` Ingest coverage\n3. NEW fidelity/token-budget prerequisite issue (this issue)\n4. `openclaw-3fc` Real summarizer\n5. `openclaw-b68` Enable assemble (depends on 512, 623, NEW, 3fc)\n6. `openclaw-e98` Threshold compaction (depends on b68)\n7. `openclaw-b80` Disable Pi auto-compaction (depends on b68, e98)","priority":"1","title":"LCM prerequisite: preserve message fidelity and plumb token budget into assemble/compact","type":"task"}}
{"type":"dep_rm","timestamp":"2026-02-13T21:48:14.900013Z","issue_id":"openclaw-b68","payload":{"dep_type":"blocks","depends_on":"openclaw-b80"}}
{"type":"dep_add","timestamp":"2026-02-13T21:48:14.96128Z","issue_id":"openclaw-b68","payload":{"dep_type":"blocks","depends_on":"openclaw-512"}}
{"type":"dep_add","timestamp":"2026-02-13T21:48:15.016775Z","issue_id":"openclaw-b68","payload":{"dep_type":"blocks","depends_on":"openclaw-623"}}
{"type":"dep_add","timestamp":"2026-02-13T21:48:15.073775Z","issue_id":"openclaw-b68","payload":{"dep_type":"blocks","depends_on":"openclaw-c4c"}}
{"type":"dep_add","timestamp":"2026-02-13T21:48:15.131016Z","issue_id":"openclaw-b68","payload":{"dep_type":"blocks","depends_on":"openclaw-3fc"}}
{"type":"dep_add","timestamp":"2026-02-13T21:48:15.192916Z","issue_id":"openclaw-e98","payload":{"dep_type":"blocks","depends_on":"openclaw-b68"}}
{"type":"dep_rm","timestamp":"2026-02-13T21:48:15.246157Z","issue_id":"openclaw-b80","payload":{"dep_type":"blocks","depends_on":"openclaw-512"}}
{"type":"dep_rm","timestamp":"2026-02-13T21:48:15.302641Z","issue_id":"openclaw-b80","payload":{"dep_type":"blocks","depends_on":"openclaw-623"}}
{"type":"dep_rm","timestamp":"2026-02-13T21:48:15.368486Z","issue_id":"openclaw-b80","payload":{"dep_type":"blocks","depends_on":"openclaw-3fc"}}
{"type":"dep_add","timestamp":"2026-02-13T21:48:15.430367Z","issue_id":"openclaw-b80","payload":{"dep_type":"blocks","depends_on":"openclaw-b68"}}
{"type":"dep_add","timestamp":"2026-02-13T21:48:15.48704Z","issue_id":"openclaw-b80","payload":{"dep_type":"blocks","depends_on":"openclaw-e98"}}
{"type":"status_update","timestamp":"2026-02-13T21:51:55.030752Z","issue_id":"openclaw-623","payload":{"status":"in_progress"}}
{"type":"status_update","timestamp":"2026-02-13T21:51:57.739589Z","issue_id":"openclaw-c4c","payload":{"status":"in_progress"}}
{"type":"status_update","timestamp":"2026-02-13T21:53:26.655049Z","issue_id":"openclaw-3fc","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-13T21:56:26.63816Z","issue_id":"openclaw-623","payload":{}}
{"type":"status_update","timestamp":"2026-02-13T21:58:33.124974Z","issue_id":"openclaw-512","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-13T21:58:56.076108Z","issue_id":"openclaw-512","payload":{}}
{"type":"close","timestamp":"2026-02-13T21:59:04.799965Z","issue_id":"openclaw-3fc","payload":{}}
{"type":"close","timestamp":"2026-02-13T22:00:41.198018Z","issue_id":"openclaw-c4c","payload":{}}
{"type":"close","timestamp":"2026-02-13T22:03:04.218953Z","issue_id":"openclaw-512","payload":{}}
{"type":"close","timestamp":"2026-02-13T22:03:04.218953Z","issue_id":"openclaw-623","payload":{}}
{"type":"close","timestamp":"2026-02-13T22:03:04.218953Z","issue_id":"openclaw-c4c","payload":{}}
{"type":"close","timestamp":"2026-02-13T22:03:04.218953Z","issue_id":"openclaw-3fc","payload":{}}
{"type":"status_update","timestamp":"2026-02-13T22:09:02.289992Z","issue_id":"openclaw-b68","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-13T22:09:21.299279Z","issue_id":"openclaw-b68","payload":{}}
{"type":"close","timestamp":"2026-02-14T00:02:03.583166Z","issue_id":"openclaw-623","payload":{}}
{"type":"close","timestamp":"2026-02-14T00:08:11.62404Z","issue_id":"openclaw-c4c","payload":{}}
{"type":"close","timestamp":"2026-02-14T00:18:11.003003Z","issue_id":"openclaw-3fc","payload":{}}
{"type":"close","timestamp":"2026-02-14T00:26:35.319973Z","issue_id":"openclaw-b68","payload":{}}
{"type":"status_update","timestamp":"2026-02-14T00:35:11.242065Z","issue_id":"openclaw-e98","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-14T00:42:24.309841Z","issue_id":"openclaw-e98","payload":{}}
{"type":"close","timestamp":"2026-02-14T00:49:19.953008Z","issue_id":"openclaw-b80","payload":{}}
{"type":"create","timestamp":"2026-02-14T16:03:20.232867Z","issue_id":"openclaw-58a","payload":{"description":"## Goal\nHarden current LCM expansion behavior to make it bounded, auditable, and authorization-ready for delegated traversal.\n\n## Why this exists\nCurrent implementation has three concrete gaps:\n1. `lcm_expand` can run effectively unbounded when `tokenCap` is omitted in the agent tool path.\n2. Compaction rewrites context but does not emit durable compaction event parts in `message_parts`.\n3. `ExpansionAuthManager` exists but is not wired into runtime usage.\n\nThese are prerequisites for safe, automatic multi-hop subagent expansion.\n\n## Scope\nThis epic delivers only runtime hardening and guardrails. It does **not** implement full automatic route-and-spawn orchestration policy.\n\n## Deliverables\n- Enforced default + max cap behavior for `lcm_expand`\n- Durable compaction event part writes with token/accounting metadata\n- Runtime grant issuance/validation plumbing for delegated expansion\n\n## Non-goals\n- No product-level auto-orchestration policy changes (handled in separate epic)\n- No DB backend migration (SQLite remains the intended backend)","priority":"1","title":"LCM: expansion hardening (caps, compaction audit events, auth grants)","type":"epic"}}
{"type":"create","timestamp":"2026-02-14T16:03:20.300986Z","issue_id":"openclaw-cdc","payload":{"description":"## Problem\n`lcm_expand` defaults are inconsistent by entrypoint:\n- Plugin helper path (`buildExpansionToolDefinition`) defaults to `config.maxExpandTokens`.\n- Agent tool path (`createLcmExpandTool`) leaves `tokenCap` undefined, which propagates to orchestrator as effectively unbounded (`Infinity`).\n\nThis can produce oversized expansions and context blowups, especially in subagent deep traversal.\n\n## Current code references\n- `src/agents/tools/lcm-expand-tool.ts`\n- `src/plugins/lcm/expansion.ts`\n- `src/plugins/lcm/db/config.ts` (`maxExpandTokens`)\n\n## Required behavior\n1. If caller omits `tokenCap`, apply default from LCM config (`maxExpandTokens`).\n2. If caller supplies `tokenCap`, clamp to an explicit max (same config value unless a separate hard cap is introduced).\n3. Keep existing behavior for query-based and direct-summary expansion, except now always bounded.\n4. Preserve backward-compatible response shape (`content`, `details`).\n\n## Implementation notes\n- Ensure the cap logic is applied in **all** runtime entrypoints for expansion (not only helper utilities).\n- Keep failure behavior and error messages stable unless clearly improving correctness.\n- Do not silently widen limits beyond configured bounds.\n\n## Acceptance criteria\n- Omitting `tokenCap` in `lcm_expand` produces bounded expansion using configured default.\n- Oversized requested `tokenCap` is clamped (or rejected with clear error, if that design is chosen and documented).\n- Existing lcm expansion tests pass; add tests proving bounded defaults/clamping in agent tool path.\n\n## Test plan\n- Unit tests for cap resolution logic in expansion tool path.\n- Regression tests for both query and summary-id expansion modes.\n- Run relevant LCM + tool tests via Vitest.\n\n## Out of scope\n- Automatic subagent spawn policy.","priority":"1","title":"LCM: enforce bounded default/clamped token caps for lcm_expand","type":"task"}}
{"type":"create","timestamp":"2026-02-14T16:03:20.371782Z","issue_id":"openclaw-fc1","payload":{"description":"## Problem\nCompaction mutates context graph state (summaries/lineage/context_items) but does not emit durable compaction event parts into `message_parts`.\n\nThe spec intent is to retain an auditable operation trail for each compaction pass.\n\n## Current code references\n- `src/plugins/lcm/compaction.ts`\n- `src/plugins/lcm/engine.ts` (compact call flow)\n- `src/plugins/lcm/store/conversation-store.ts` (message/message_parts APIs)\n- `src/plugins/lcm/db/migration.ts` (`part_type=compaction` exists in schema)\n\n## Required behavior\n1. On each successful compaction action (leaf and/or condensed pass), write a compact event record into canonical history.\n2. Persist event as `message_parts.part_type=compaction` with metadata sufficient for auditability.\n3. Event metadata should include at minimum:\n   - `conversationId`\n   - compaction level (`normal|aggressive|fallback`)\n   - `tokensBefore`, `tokensAfter`\n   - created summary id(s)\n   - whether condensed pass occurred\n4. Ensure event writes are resilient and do not corrupt compaction flow on partial failures.\n\n## Design constraints\n- Canonical data remains append-first and non-destructive.\n- Do not re-architect compaction algorithm in this task.\n- Keep event write semantics deterministic and testable.\n\n## Acceptance criteria\n- Compaction run produces at least one `message_parts` row with `part_type=compaction`.\n- Stored metadata includes token deltas + summary references.\n- Existing compaction behavior remains functionally unchanged except event emission.\n\n## Test plan\n- Add tests asserting compaction event part creation and metadata fields.\n- Cover leaf-only and leaf+condensed scenarios.\n- Run LCM engine/integration tests.\n\n## Out of scope\n- Adding external metrics pipeline wiring.","priority":"1","title":"LCM: emit durable compaction event parts in canonical history","type":"task"}}
{"type":"create","timestamp":"2026-02-14T16:03:20.440249Z","issue_id":"openclaw-19d","payload":{"description":"## Problem\n`ExpansionAuthManager` and `wrapWithAuth` exist but are not wired into runtime flows. Delegated/subagent expansion therefore has no enforced grant boundaries in production code paths.\n\n## Current code references\n- `src/plugins/lcm/expansion-auth.ts`\n- `src/plugins/lcm/expansion.ts`\n- `src/agents/tools/lcm-expand-tool.ts`\n- `src/agents/tools/sessions-spawn-tool.ts`\n- `src/agents/subagent-registry.ts`\n\n## Required behavior\n1. Introduce runtime grant lifecycle for delegated expansion:\n   - grant creation by parent/orchestrator context\n   - grant propagation to delegated run\n   - grant validation in expansion execution path\n2. Enforce at least these grant constraints:\n   - allowed conversation scope\n   - optional allowed summary ID scope\n   - max depth\n   - max token cap\n   - expiry + revocation handling\n3. Ensure non-delegated/local expansion still works without unnecessary friction.\n\n## Implementation guidance\n- Prefer a small integration surface first; avoid over-design.\n- Use existing `ExpansionAuthManager` semantics unless a concrete runtime mismatch requires adaptation.\n- Keep error messages actionable (authorization failure should explain which constraint failed).\n- If a transport mechanism is needed (session metadata, tool params, or both), document and test it.\n\n## Acceptance criteria\n- Delegated expansion attempts without valid grant are rejected.\n- Delegated expansion with valid grant succeeds within grant limits.\n- Expired/revoked grants fail with clear errors.\n- Existing direct local use-cases remain functional.\n\n## Test plan\n- Integration tests for grant create/use/fail paths.\n- Include depth/token cap and conversation scope violations.\n- Run LCM + sessions_spawn related tests.\n\n## Out of scope\n- Full automatic orchestration policy (separate epic).","priority":"1","title":"LCM: wire ExpansionAuthManager into delegated/runtime expansion flows","type":"task"}}
{"type":"rename","timestamp":"2026-02-14T16:03:20.506133Z","issue_id":"openclaw-cdc","payload":{"new_id":"openclaw-58a.1"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:20.506133Z","issue_id":"openclaw-58a.1","payload":{"dep_type":"parent-child","depends_on":"openclaw-58a"}}
{"type":"rename","timestamp":"2026-02-14T16:03:20.586586Z","issue_id":"openclaw-fc1","payload":{"new_id":"openclaw-58a.2"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:20.586586Z","issue_id":"openclaw-58a.2","payload":{"dep_type":"parent-child","depends_on":"openclaw-58a"}}
{"type":"rename","timestamp":"2026-02-14T16:03:20.653609Z","issue_id":"openclaw-19d","payload":{"new_id":"openclaw-58a.3"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:20.653609Z","issue_id":"openclaw-58a.3","payload":{"dep_type":"parent-child","depends_on":"openclaw-58a"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:20.730518Z","issue_id":"openclaw-58a","payload":{"dep_type":"blocks","depends_on":"openclaw-58a.1"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:20.798939Z","issue_id":"openclaw-58a","payload":{"dep_type":"blocks","depends_on":"openclaw-58a.2"}}
{"type":"close","timestamp":"2026-02-14T16:03:39.033372Z","issue_id":"openclaw-548","payload":{}}
{"type":"close","timestamp":"2026-02-14T16:03:43.852121Z","issue_id":"openclaw-b2b","payload":{}}
{"type":"close","timestamp":"2026-02-14T16:03:43.951547Z","issue_id":"openclaw-f41","payload":{}}
{"type":"close","timestamp":"2026-02-14T16:03:44.047846Z","issue_id":"openclaw-4d5","payload":{}}
{"type":"dep_rm","timestamp":"2026-02-14T16:03:49.829943Z","issue_id":"openclaw-58a.1","payload":{"dep_type":"parent-child","depends_on":"openclaw-58a"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:49.829943Z","issue_id":"openclaw-58a.1","payload":{"dep_type":"parent-child","depends_on":"openclaw-58a"}}
{"type":"dep_rm","timestamp":"2026-02-14T16:03:49.903313Z","issue_id":"openclaw-58a.2","payload":{"dep_type":"parent-child","depends_on":"openclaw-58a"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:49.903313Z","issue_id":"openclaw-58a.2","payload":{"dep_type":"parent-child","depends_on":"openclaw-58a"}}
{"type":"dep_rm","timestamp":"2026-02-14T16:03:49.976586Z","issue_id":"openclaw-58a.3","payload":{"dep_type":"parent-child","depends_on":"openclaw-58a"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:49.976586Z","issue_id":"openclaw-58a.3","payload":{"dep_type":"parent-child","depends_on":"openclaw-58a"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:50.048213Z","issue_id":"openclaw-58a","payload":{"dep_type":"blocks","depends_on":"openclaw-58a.1"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:50.152285Z","issue_id":"openclaw-58a","payload":{"dep_type":"blocks","depends_on":"openclaw-58a.2"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:50.263972Z","issue_id":"openclaw-58a","payload":{"dep_type":"blocks","depends_on":"openclaw-58a.3"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:50.340289Z","issue_id":"openclaw-58a.3","payload":{"dep_type":"blocks","depends_on":"openclaw-58a.1"}}
{"type":"create","timestamp":"2026-02-14T16:03:50.415034Z","issue_id":"openclaw-efb","payload":{"description":"## Goal\nImplement full automatic spec-style LCM expansion orchestration:\n- main agent routes via describe/grep\n- system auto-delegates deep traversal to subagents when appropriate\n- subagents return distilled findings with cited IDs\n\n## Why this exists\nToday, subagent-based expansion is possible manually (using `sessions_spawn` + LCM tools), but not automatically orchestrated as a first-class runtime behavior.\n\n## Scope\nDeliver policy + runtime orchestration + validation for autonomous route-and-delegate expansion loops.\n\n## Prerequisites\nThis epic assumes hardening work is complete:\n- bounded expansion caps\n- compaction audit events\n- grant-based authorization for delegated traversal\n\n## Success criteria\n- Main agent automatically chooses direct vs delegated expansion based on objective risk/complexity signals.\n- Delegated expansion remains bounded and auditable.\n- User-facing responses are concise; raw expansion payloads do not flood top-level context.","priority":"1","title":"LCM: full automatic spec-style subagent expansion orchestration","type":"epic"}}
{"type":"create","timestamp":"2026-02-14T16:03:50.49112Z","issue_id":"openclaw-6a6","payload":{"description":"## Objective\nDefine and implement deterministic orchestration policy for when the main agent should:\n1. answer directly,\n2. do shallow/direct `lcm_expand`, or\n3. spawn delegated subagent traversal.\n\n## Required decision model\nImplement explicit trigger heuristics (documented + tested), including at least:\n- traversal depth requested/estimated\n- number of candidate summary IDs\n- estimated token risk vs configured caps\n- broad time-range / multi-hop retrieval indicators\n\n## Required output contract\n- Parent run should receive concise synthesis + cited IDs.\n- Avoid dumping full raw expansion payload into top-level context.\n\n## Files likely touched\n- `src/agents/...` orchestration or tool-invocation layer\n- `src/plugins/lcm/expansion.ts` (if helper contracts need extension)\n- system prompt/tool guidance files if needed\n\n## Acceptance criteria\n- Policy logic is explicit (not purely prompt magic) and unit-tested.\n- Decision outcomes are explainable in logs/debug metadata.\n- No regression for existing manual `sessions_spawn` workflows.\n\n## Test plan\n- Unit tests for policy decisions across representative scenarios.\n- Include boundary cases near token/depth thresholds.","priority":"1","title":"LCM Orchestration: implement deterministic route-vs-delegate policy","type":"task"}}
{"type":"create","timestamp":"2026-02-14T16:03:50.60103Z","issue_id":"openclaw-e35","payload":{"description":"## Objective\nImplement end-to-end automatic orchestration runtime so deep LCM expansion can happen without manual `sessions_spawn` choreography.\n\n## Required behavior\n1. Main agent identifies candidate IDs via describe/grep.\n2. If policy selects delegation, system spawns subagent with narrow task and bounds.\n3. Subagent performs bounded expansion (under grants + caps).\n4. Subagent returns distilled findings + cited IDs.\n5. Main agent optionally performs additional focused passes or final response synthesis.\n\n## Required safeguards\n- Enforce grant scope for delegated expansions.\n- Enforce token/depth bounds throughout all passes.\n- Ensure cleanup/archive behavior for spawned subagent sessions remains correct.\n\n## Integration points\n- `sessions_spawn` path and subagent lifecycle\n- LCM expansion tool execution\n- parent/child messaging and announce flow\n\n## Acceptance criteria\n- Automatic delegated expansion works end-to-end with no manual subagent invocation.\n- Final top-level response stays concise and user-oriented.\n- Failure modes (timeout, auth denial, no matches) degrade gracefully.\n\n## Test plan\n- E2E tests covering route-only, single delegated pass, and multi-pass follow-up.\n- Timeout/error-path tests for child runs.\n- Regression tests for existing session tool behavior.","priority":"1","title":"LCM Orchestration: wire automatic delegated expansion runtime loop","type":"task"}}
{"type":"create","timestamp":"2026-02-14T16:03:50.722984Z","issue_id":"openclaw-849","payload":{"description":"## Objective\nAdd comprehensive verification and operational documentation for automatic orchestration.\n\n## Required outputs\n1. Test coverage additions:\n   - policy decision matrix\n   - grant/bounds enforcement in delegated runs\n   - end-to-end orchestration outcomes\n2. Observability outputs:\n   - structured logs or debug metadata that identify decision path and delegated run references\n3. Documentation updates:\n   - operator-facing behavior and limits\n   - how to tune/disable/inspect orchestration\n\n## Acceptance criteria\n- Tests clearly prove correctness and safety constraints.\n- Docs are sufficient for operators to understand behavior without reading code.\n- No stale references to PostgreSQL for LCM backend; SQLite language remains canonical.\n\n## Test plan\n- Execute full targeted test suite for orchestration and related LCM/subagent paths.\n- Include explicit assertions for boundedness and cited-ID handoff.","priority":"2","title":"LCM Orchestration: add E2E validation, observability, and docs","type":"task"}}
{"type":"rename","timestamp":"2026-02-14T16:03:50.818628Z","issue_id":"openclaw-6a6","payload":{"new_id":"openclaw-efb.1"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:50.818628Z","issue_id":"openclaw-efb.1","payload":{"dep_type":"parent-child","depends_on":"openclaw-efb"}}
{"type":"rename","timestamp":"2026-02-14T16:03:50.906685Z","issue_id":"openclaw-e35","payload":{"new_id":"openclaw-efb.2"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:50.906685Z","issue_id":"openclaw-efb.2","payload":{"dep_type":"parent-child","depends_on":"openclaw-efb"}}
{"type":"rename","timestamp":"2026-02-14T16:03:51.007177Z","issue_id":"openclaw-849","payload":{"new_id":"openclaw-efb.3"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:51.007177Z","issue_id":"openclaw-efb.3","payload":{"dep_type":"parent-child","depends_on":"openclaw-efb"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:51.115338Z","issue_id":"openclaw-efb","payload":{"dep_type":"blocks","depends_on":"openclaw-efb.1"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:51.222061Z","issue_id":"openclaw-efb","payload":{"dep_type":"blocks","depends_on":"openclaw-efb.2"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:51.370394Z","issue_id":"openclaw-efb","payload":{"dep_type":"blocks","depends_on":"openclaw-efb.3"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:51.487452Z","issue_id":"openclaw-efb.1","payload":{"dep_type":"blocks","depends_on":"openclaw-58a.1"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:51.619603Z","issue_id":"openclaw-efb.1","payload":{"dep_type":"blocks","depends_on":"openclaw-58a.3"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:51.706481Z","issue_id":"openclaw-efb.2","payload":{"dep_type":"blocks","depends_on":"openclaw-efb.1"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:51.785555Z","issue_id":"openclaw-efb.2","payload":{"dep_type":"blocks","depends_on":"openclaw-58a.1"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:51.86297Z","issue_id":"openclaw-efb.2","payload":{"dep_type":"blocks","depends_on":"openclaw-58a.2"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:51.951689Z","issue_id":"openclaw-efb.2","payload":{"dep_type":"blocks","depends_on":"openclaw-58a.3"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:52.032523Z","issue_id":"openclaw-efb.3","payload":{"dep_type":"blocks","depends_on":"openclaw-efb.2"}}
{"type":"dep_add","timestamp":"2026-02-14T16:03:52.114904Z","issue_id":"openclaw-efb","payload":{"dep_type":"blocks","depends_on":"openclaw-58a"}}
{"type":"status_update","timestamp":"2026-02-14T16:10:58.483634Z","issue_id":"openclaw-58a.2","payload":{"status":"in_progress"}}
{"type":"status_update","timestamp":"2026-02-14T16:11:05.807999Z","issue_id":"openclaw-58a.1","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-14T16:14:14.583361Z","issue_id":"openclaw-58a.1","payload":{}}
{"type":"close","timestamp":"2026-02-14T16:15:06.813852Z","issue_id":"openclaw-58a.2","payload":{}}
{"type":"status_update","timestamp":"2026-02-14T16:19:13.070278Z","issue_id":"openclaw-58a.3","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-14T16:27:15.774102Z","issue_id":"openclaw-58a.3","payload":{}}
{"type":"create","timestamp":"2026-02-14T16:38:45.688574Z","issue_id":"openclaw-8fa","payload":{"description":"## Bug\nSome sessions contain assistant messages where `content` is a string (legacy or reconstructed history).\n`@mariozechner/pi-ai` assumes assistant content is always array-shaped and calls `assistantMsg.content.flatMap(...)`, which throws:\n\n`assistantMsg.content.flatMap is not a function`\n\n## Repro\n- Send a follow-up prompt in a session where assistant history contains string `content`\n- Observe error surfaced back to chat\n\n## Scope\n- Seen in runtime path during history sanitize / context assemble before next model call\n\n## Proposed fix\nNormalize assistant message content to array text blocks before model handoff and after context assembly output.\n\n## Notes\nReported via screenshot from Telegram chat; message text was repeated as runtime error output.","priority":"0","title":"Assistant content shape crash in pi-ai transformMessages","type":"bug"}}
{"type":"status_update","timestamp":"2026-02-14T17:43:11.780491Z","issue_id":"openclaw-efb.1","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-14T17:47:16.169786Z","issue_id":"openclaw-efb.1","payload":{}}
{"type":"create","timestamp":"2026-02-14T18:14:52.998744Z","issue_id":"openclaw-8a5","payload":{"description":"The LCM context engine proactive compaction fails with 'Error: database is not open'. The SQLite connection is getting closed/disposed prematurely between agent turns, so when compact() is called the DB handle is stale.\n\nLogs show repeated failures:\n[agent/embedded] context engine proactive compact failed: Error: database is not open\n\nThe system falls back to legacy Pi safeguard compaction, so not catastrophic, but LCM summaries are never created.\n\nRoot cause likely in LcmContextEngine.dispose() calling closeLcmConnection() too early — possibly at end of each agent turn instead of at gateway shutdown. Or the connection singleton is shared and closed by one consumer while another still needs it.\n\nKey files:\n- src/plugins/lcm/engine.ts (dispose method)\n- src/plugins/lcm/db/connection.ts (connection singleton)\n- src/agents/pi-embedded-runner/run.ts (where dispose is called)","priority":"0","title":"LCM proactive compact fails: database is not open","type":"bug"}}
{"type":"status_update","timestamp":"2026-02-14T18:18:14.416337Z","issue_id":"openclaw-8a5","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-14T18:18:28.700375Z","issue_id":"openclaw-8a5","payload":{}}
{"type":"status_update","timestamp":"2026-02-14T20:57:50.584097Z","issue_id":"openclaw-efb.2","payload":{"status":"in_progress"}}
{"type":"create","timestamp":"2026-02-14T20:58:43.08541Z","issue_id":"openclaw-9dc","payload":{"description":"## Bug\nWhen LCM is enabled, each run resolves a new `LcmContextEngine` instance but `db/connection.ts` used a single process-global sqlite handle.\n`run.ts` always calls `contextEngine.dispose()` at end of run. In concurrent runs, one run finishing can close the shared DB while another run is still ingesting/compacting, causing:\n\n- `context engine ingest failed: Error: database is not open`\n- `context engine proactive compact failed: Error: database is not open`\n\n## Fix\nUse ref-counted connections keyed by db path in `src/plugins/lcm/db/connection.ts`, and release by path in `LcmContextEngine.dispose()`.\n\n## Validation\nAdd regression test in `src/plugins/lcm/engine.test.ts` to verify one engine disposal does not break another active engine using the same DB path.","priority":"0","title":"LCM shared sqlite handle can close during concurrent runs","type":"bug"}}
{"type":"comment","timestamp":"2026-02-14T21:07:15.280966Z","issue_id":"openclaw-efb.2","payload":{"body":"Implemented automatic delegated LCM expansion runtime loop in lcm_expand with bounded multi-pass subagent execution, grant-scoped conversation/token enforcement, and direct-expansion fallback for timeout/error cases. Added integration + e2e coverage for route-only, delegated, timeout, and error paths."}}
{"type":"close","timestamp":"2026-02-14T21:07:15.361308Z","issue_id":"openclaw-efb.2","payload":{}}
{"type":"status_update","timestamp":"2026-02-14T21:21:41.061342Z","issue_id":"openclaw-efb.3","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-14T21:27:40.377926Z","issue_id":"openclaw-efb.3","payload":{}}
{"type":"comment","timestamp":"2026-02-14T21:28:31.431977Z","issue_id":"openclaw-efb.3","payload":{"body":"Completed: added lcm_expand observability metadata (decision path + delegated run refs), expanded policy matrix + delegated bounds/cited-ID handoff tests, added orchestration fallback E2E assertions, and documented operator tuning/disable/inspect behavior with SQLite-canonical wording in docs/tools/subagents.md. Commits: 73b5daad6, 814141532."}}
{"type":"create","timestamp":"2026-02-14T21:40:13.568802Z","issue_id":"openclaw-95b","payload":{"description":"Empty model summarizer responses in LCM currently throw and abort proactive compaction. Add deterministic fallback output and regression tests; also clarify compact reason when rounds=0.","priority":"2","title":"LCM compaction: fallback on empty summarizer output","type":"task"}}
{"type":"close","timestamp":"2026-02-14T21:42:21.482472Z","issue_id":"openclaw-95b","payload":{}}
{"type":"create","timestamp":"2026-02-14T22:01:05.863828Z","issue_id":"openclaw-991","payload":{"description":"Test that LCM works correctly on first run / after DB reset:\n\n1. Back up current lcm.db\n2. Delete ~/.openclaw/lcm.db\n3. Restart gateway\n4. Verify LCM creates conversations, ingests messages, builds context_items from scratch\n5. Verify it bootstraps from existing session JSONL (backfills historical messages)\n6. Confirm no 'database is not open' errors\n\nKey question: does the bootstrap path (openclaw-512) get exercised automatically on first run, or is it manual?\n\nContext: The ingest reliability fix (f6007bab4) is now integrated and working — zero db-not-open errors since restart. But we need to verify the cold-start path works too.","priority":"2","title":"LCM bootstrap test: delete DB and verify fresh hydration from session JSONL","type":"task"}}
{"type":"close","timestamp":"2026-02-14T22:19:04.433548Z","issue_id":"openclaw-58a","payload":{}}
{"type":"close","timestamp":"2026-02-14T22:19:04.511903Z","issue_id":"openclaw-efb","payload":{}}
{"type":"close","timestamp":"2026-02-14T22:23:30.273031Z","issue_id":"openclaw-9dc","payload":{}}
{"type":"create","timestamp":"2026-02-14T22:30:44.90808Z","issue_id":"openclaw-b70","payload":{"description":"Improve lcm_grep, lcm_expand, and lcm_describe for practical agent use:\n\n1. **lcm_grep: time filters + recency sort**\n   - Add since/before parameters (ISO timestamps)\n   - Return timestamps with each result\n   - Default sort by recency (most recent first)\n\n2. **lcm_expand: recency bias in query mode**\n   - When using query-based expansion, bias toward more recent summaries\n   - Drop the hard requirement for conversationId when query is provided — infer from session\n\n3. **Auto-scope to current session's conversation**\n   - All three tools should default to the current agent's conversation, not search across all agents\n   - The agent runtime should pass conversationId implicitly so the tools don't require it as a parameter\n   - Cross-conversation search should still be possible with an explicit flag\n\nContext: Currently lcm_grep returns 20 results with no timestamps or ordering, making it hard to find recent context. lcm_expand query mode errors without conversationId. Agents should be looking at their own history by default.","priority":"1","title":"LCM retrieval: add time filters, recency sorting, and auto-scoping","type":"task"}}
{"type":"status_update","timestamp":"2026-02-14T22:32:12.066835Z","issue_id":"openclaw-b70","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-14T22:40:47.492477Z","issue_id":"openclaw-b70","payload":{}}
{"type":"create","timestamp":"2026-02-14T22:48:15.650974Z","issue_id":"openclaw-fe7","payload":{"description":"After /compact, the reported token count (e.g. '48k → 1.7k') only reflects LCM conversation data (summaries + messages). It excludes system prompts, workspace files, and skills — making 'Context 1.7k/200k (1%)' misleadingly low. Fix: estimate system prompt overhead and add to tokensAfter in commands-compact.ts.","priority":"2","title":"Post-compaction token display excludes system prompts","type":"bug"}}
{"type":"close","timestamp":"2026-02-14T22:49:14.696054Z","issue_id":"openclaw-fe7","payload":{}}
{"type":"create","timestamp":"2026-02-15T04:11:11.350514Z","issue_id":"openclaw-5e9","payload":{"description":"Heartbeat turns are ingested into LCM canonical store where legacy engine discarded them. Two fixes needed: (1) filter heartbeat turns from LCM ingest or mark ephemeral, (2) fix token accounting mismatch where extractMessageContent misses raw/metadata blocks causing compaction threshold to never trigger. Investigation: INVESTIGATION.md on branch investigate-heartbeat-context-growth (commit 756c51268).","priority":"1","title":"LCM heartbeat context growth fixes","type":"epic"}}
{"type":"create","timestamp":"2026-02-15T04:11:20.53445Z","issue_id":"openclaw-bc5","payload":{"description":"LCM ingests all heartbeat tool call/result pairs into canonical context where legacy engine did not (legacy ingest was a no-op). Each heartbeat poll adds ~16k tokens of worker snapshot data. Fix: detect heartbeat turns in LCM ingestBatch/ingestSingle and either skip them entirely or mark them as ephemeral/low-priority so they don't accumulate in assembled context.\n\nKey files:\n- src/plugins/lcm/engine.ts (ingestSingle at :489, :507)\n- src/agents/pi-embedded-runner/run/attempt.ts (ingestBatch at :998, isHeartbeat flag available from :995)\n- src/infra/heartbeat-runner.ts (isHeartbeat marker at :606)\n\nTDD approach: Write tests first that verify heartbeat messages are NOT present in assembled context after ingest. Verify tests fail on current code, then implement the fix, verify tests pass.","priority":"1","title":"Filter heartbeat turns from LCM ingest","type":"task"}}
{"type":"create","timestamp":"2026-02-15T04:11:30.038602Z","issue_id":"openclaw-a40","payload":{"description":"LCM compaction threshold decision undercounts real assembled payload. extractMessageContent misses large non-text/raw metadata blocks during tokenization, but the assembler rehydrates those full blocks. Observed: context_items token sum was 136k but actual reconstructed payload was ~357k tokens. Compaction threshold (75% of 204k = 153k) never triggers despite context being way over.\n\nKey files:\n- src/plugins/lcm/compaction.ts (:82, :89 - threshold decision using getContextTokenCount)\n- src/plugins/lcm/engine.ts (:108 - extractMessageContent for tokenization)  \n- src/plugins/lcm/assembler.ts (:99, :151 - rehydrates raw blocks from message_parts.metadata.raw)\n- src/agents/pi-embedded-runner/run/attempt.ts (:189 - estimateSessionTokenCount)\n\nTDD approach: Write tests that create messages with large raw/metadata blocks, verify getContextTokenCount returns accurate counts matching what the assembler would produce. Verify tests fail on current code, then fix extractMessageContent/tokenization to account for raw metadata, verify tests pass.","priority":"1","title":"Fix LCM compaction token accounting mismatch","type":"task"}}
{"type":"dep_add","timestamp":"2026-02-15T04:11:33.20847Z","issue_id":"openclaw-5e9","payload":{"dep_type":"blocks","depends_on":"openclaw-bc5"}}
{"type":"dep_add","timestamp":"2026-02-15T04:11:33.311941Z","issue_id":"openclaw-5e9","payload":{"dep_type":"blocks","depends_on":"openclaw-a40"}}
{"type":"status_update","timestamp":"2026-02-15T04:12:21.408824Z","issue_id":"openclaw-a40","payload":{"status":"in_progress"}}
{"type":"status_update","timestamp":"2026-02-15T04:12:34.449787Z","issue_id":"openclaw-bc5","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-15T04:15:42.753078Z","issue_id":"openclaw-a40","payload":{}}
{"type":"close","timestamp":"2026-02-15T04:18:03.51842Z","issue_id":"openclaw-bc5","payload":{}}
{"type":"close","timestamp":"2026-02-15T04:26:45.021877Z","issue_id":"openclaw-5e9","payload":{}}
{"type":"create","timestamp":"2026-02-17T06:42:28.275849Z","issue_id":"openclaw-537","payload":{"description":"Per the LCM paper (Ehrlich \u0026 Blackman, 2026), lcm_expand should be restricted to sub-agents only. The main agent should not be able to expand summaries inline in its context window.\n\n**Rationale:** Expanding compacted summaries in the main interaction loop risks context flooding — you compact to save space, then immediately re-expand and blow the context back up. The paper restricts expand to sub-agents so that expansion happens in an isolated context window, and only the relevant findings are returned to the parent.\n\n**Current behavior:** The main agent can call lcm_expand on any summary with no restriction. The expansion-policy routing may delegate heavy traversals to sub-agents, but this is an optimization, not a hard restriction. The only protection is a token cap (default 4000 tokens).\n\n**Desired behavior:**\n- Main agent cannot call lcm_expand directly\n- Main agent can only observe summaries in its context (via lcm_describe and lcm_grep)\n- When the main agent needs to drill into a summary, it delegates to a sub-agent via the existing expansion grant system\n- Sub-agents can call lcm_expand with proper grants (already implemented)\n\n**Implementation notes:**\n- The grant system in expansion-auth.ts already exists for sub-agent scoping\n- The delegation loop in lcm-expand-tool.delegation.ts already handles sub-agent expansion\n- Main change: add a guard in lcm-expand-tool.ts that rejects calls from non-subagent sessions\n- Consider providing a helpful error message pointing the agent to use lcm_describe instead, or to delegate via a sub-agent task\n\nThis becomes more important with incremental compaction (many small summaries), where expanding several small summaries could snowball context usage.","priority":"2","title":"Restrict lcm_expand to sub-agents only","type":"task"}}
{"type":"create","timestamp":"2026-02-17T07:29:06.923545Z","issue_id":"openclaw-017","payload":{"description":"Part 1 of LCM incremental compaction (spec: specs/lcm-incremental-compaction.md).\n\nFiles to modify: src/plugins/lcm/db/config.ts, src/plugins/lcm/summarize.ts\n\nConfig changes: Add leafChunkTokens to LcmConfig (default 20000), update defaults (freshTailCount 8-\u003e16, leafTargetTokens 600-\u003e1200, condensedTargetTokens 900-\u003e2000).\n\nSummarization prompts: Extend LcmSummarizeFn to accept options { previousSummary?, isCondensed? }. New leaf prompt with segment hint and previous summary context. New condensed prompt with Pi-inspired structured format and reasoning high. Keep three-level escalation.","priority":"1","title":"LCM incremental compaction: config + summarization prompts","type":"task"}}
{"type":"create","timestamp":"2026-02-17T07:29:15.192134Z","issue_id":"openclaw-eb8","payload":{"description":"Part 2 of LCM incremental compaction (spec: specs/lcm-incremental-compaction.md).\n\nFile to modify: src/plugins/lcm/compaction.ts\n\nChanges:\n1. Add evaluateLeafTrigger() - checks if raw msg tokens outside fresh tail \u003e= leafChunkTokens\n2. Refactor leafPass to take only oldest chunk up to leafChunkTokens (not all compactable msgs)\n3. Update leafPass signature to accept previousSummaryContent for continuity\n4. Refactor condensedPass to use ratio-based chunking (~17 summaries per pass, ~20k tokens of summary content -\u003e ~2000 tokens)\n5. Add compactLeaf() method for soft trigger (single leaf pass only)\n6. Add compactFullSweep() method for hard trigger - Phase 1: all raw msgs outside fresh tail -\u003e chunked leaf passes, Phase 2: ratio-based condensed passes until utilization drops\n7. Update CompactionConfig to include leafChunkTokens\n8. Update summarize callback signature to match new LcmSummarizeFn (previousSummary, isCondensed options)\n9. Keep three-level escalation (normal -\u003e aggressive -\u003e deterministic fallback)\n10. Keep persistCompactionEvents as-is","priority":"1","title":"LCM incremental compaction: CompactionEngine core","type":"task"}}
{"type":"create","timestamp":"2026-02-17T07:29:23.652864Z","issue_id":"openclaw-cfb","payload":{"description":"Part 3 of LCM incremental compaction (spec: specs/lcm-incremental-compaction.md).\n\nFiles to modify: src/plugins/lcm/engine.ts, src/agents/pi-embedded-runner/run/attempt.ts\n\nEngine changes (engine.ts):\n1. Add evaluateLeafTrigger() on LcmContextEngine - delegates to CompactionEngine.evaluateLeafTrigger\n2. Add compactLeafAsync() - uses withSessionQueue for serialization, calls CompactionEngine.compactLeaf, fire-and-forget safe\n3. Update compact() method so hard trigger / manual compaction calls compactFullSweep instead of single-round compact\n4. Pass leafChunkTokens through to CompactionConfig construction\n\nTrigger integration (attempt.ts):\n1. After ingestBatch completes (~line 1189), evaluate leaf trigger via contextEngine.evaluateLeafTrigger\n2. If shouldCompact, call contextEngine.compactLeafAsync as fire-and-forget (catch errors, log warnings)\n3. Existing hard threshold proactive compact stays - it now internally calls compactFullSweep via engine.compact\n\nDependencies: openclaw-017 (config + prompts), openclaw-eb8 (CompactionEngine core)","priority":"1","title":"LCM incremental compaction: engine wiring + soft trigger","type":"task"}}
{"type":"dep_add","timestamp":"2026-02-17T07:29:26.780268Z","issue_id":"openclaw-cfb","payload":{"dep_type":"blocks","depends_on":"openclaw-017"}}
{"type":"dep_add","timestamp":"2026-02-17T07:29:26.882442Z","issue_id":"openclaw-cfb","payload":{"dep_type":"blocks","depends_on":"openclaw-eb8"}}
{"type":"status_update","timestamp":"2026-02-17T07:31:10.175831Z","issue_id":"openclaw-017","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-17T07:33:14.090875Z","issue_id":"openclaw-017","payload":{}}
{"type":"status_update","timestamp":"2026-02-17T07:36:29.90428Z","issue_id":"openclaw-eb8","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-17T07:36:42.958318Z","issue_id":"openclaw-eb8","payload":{}}
{"type":"status_update","timestamp":"2026-02-17T14:18:02.55656Z","issue_id":"openclaw-537","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-17T14:18:13.751269Z","issue_id":"openclaw-537","payload":{}}
{"type":"create","timestamp":"2026-02-17T15:03:57.770781Z","issue_id":"openclaw-4e1","payload":{"description":"The LCM soft leaf trigger (evaluateLeafTrigger + compactLeafAsync) is currently wired in src/agents/pi-embedded-runner/run/attempt.ts alongside the hard trigger. This is a pi-embedded-runner file that can conflict when upgrading pi.\n\nIdeally all LCM compaction logic lives inside the LCM plugin. Options explored:\n1. Pass a summarizer factory or configureSoftCompaction(params) at engine init — still requires a one-liner in attempt.ts but moves all logic into the engine\n2. Use an after_ingest hook from the pi-embedded-runner\n3. Have the engine own the summarizer construction (needs provider/model/apiKey plumbing at construction time)\n\nThe core challenge: the summarizer needs provider/model/apiKey which are only known at runtime in attempt.ts, not at engine construction time. Any solution still touches attempt.ts minimally.\n\nDefer to a cleanup pass once incremental compaction is working satisfactorily.","priority":"3","title":"Refactor: move LCM soft trigger out of pi-embedded-runner attempt.ts","type":"task"}}
{"type":"create","timestamp":"2026-02-17T15:57:19.108034Z","issue_id":"openclaw-804","payload":{"description":"Implement large file handling in the LCM plugin. When a file block (\u003e25k tokens) enters via ingestSingle(), intercept it before persistence: store the raw content to disk, generate an exploration summary, insert into the existing large_files table, and rewrite the message content with a compact ~200 token reference (file ID + exploration summary). This prevents large files from blowing up active context.\n\nSpec: specs/lcm-large-file-handling.md\n\nKey implementation points:\n- Interception in engine.ts ingestSingle(), after toStoredMessage() but before createMessage()\n- Parse \u003cfile\u003e blocks via regex, check token count against threshold (25k default)\n- Store raw content at ~/.openclaw/lcm-files/\u003cconv_id\u003e/\u003cfile_id\u003e.\u003cext\u003e\n- Exploration summary: deterministic for code/structured data, LLM for unstructured text\n- File IDs propagate through compaction via existing file_ids column on summaries\n- New file: src/plugins/lcm/large-files.ts (parsing, formatting, exploration)\n- Config: largeFileTokenThreshold added to LcmConfig\n- lcm_describe already handles file_ IDs — no changes needed there\n\nAll existing storage infra (large_files table, insertLargeFile, getLargeFile, lcm_describe rendering) is already built. This wires up the missing ingestion path.","priority":"1","title":"LCM: Large file interception at ingest","type":"feature"}}
{"type":"create","timestamp":"2026-02-17T18:31:51.084001Z","issue_id":"openclaw-098","payload":{"description":"When the soft trigger fires compactLeafAsync from attempt.ts, it never passes previousSummaryContent. The plumbing exists all the way down (compactLeafAsync -\u003e compactLeaf -\u003e leafPass -\u003e summarizeWithEscalation), and the full sweep path (compactFullSweep) correctly chains previousSummaryContent between successive leaf passes.\n\nThe fix: in compactLeaf (compaction.ts), before running the leaf pass, fetch the 1-2 most recent summary context items that precede the chunk being compacted and pass their content as previousSummaryContent. This way each soft leaf pass knows what conversation preceded the messages it's summarizing, producing better continuity in the summary DAG.\n\nThe full sweep path already handles this correctly by chaining leafResult.content between passes. The gap is only in the single-pass soft trigger path where there's no prior pass to chain from.\n\nNote: freshTailCount was just bumped from 16 to 32 in a separate commit.","priority":"1","title":"LCM: soft leaf compaction should include prior summaries as continuity context","type":"task"}}
{"type":"status_update","timestamp":"2026-02-17T18:32:21.415507Z","issue_id":"openclaw-098","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-17T18:34:39.264363Z","issue_id":"openclaw-098","payload":{}}
{"type":"create","timestamp":"2026-02-17T19:06:34.789734Z","issue_id":"openclaw-a20","payload":{"description":"Messages from a complete request/response turn were lost during a gateway restart. The turn completed (delivered to Telegram) but was never persisted to LCM. Seq numbers jump from 591→592 in conversation 553 with no gap — the entire turn (user message, assistant response with tool calls finding/fixing idempotencyKey bug, multiple assistant messages) is absent from the DB.\n\nRoot cause investigation needed:\n1. Trace when LCM ingest happens relative to turn completion — is it async/deferred?\n2. Find the code path: where does the session's in-memory message state get flushed to LCM?\n3. Determine if ingest is batched on a timer, triggered by next turn, or something else\n4. Propose a fix: either sync persistence at end-of-turn, or flush-on-shutdown hook, or both\n\nKey files to start with:\n- src/plugins/lcm/engine.ts (ingestSingle, the main ingest path)\n- src/agents/pi-embedded-runner/run/attempt.ts (where compaction/LCM calls happen per-turn)\n- src/gateway/ (shutdown hooks, session persistence)\n\nEvidence: conversation 553, messages between seq 591 and 592. The full turn was visible in Telegram but never written to lcm.db.","priority":"1","title":"LCM: messages lost on gateway restart — ingest not flushed before shutdown","type":"bug"}}
{"type":"status_update","timestamp":"2026-02-17T19:07:04.021498Z","issue_id":"openclaw-a20","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-17T19:11:27.648178Z","issue_id":"openclaw-a20","payload":{}}
{"type":"status_update","timestamp":"2026-02-17T19:18:55.426219Z","issue_id":"openclaw-a20","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-17T19:21:49.662502Z","issue_id":"openclaw-a20","payload":{}}
{"type":"create","timestamp":"2026-02-17T23:13:32.7133Z","issue_id":"openclaw-b47","payload":{"description":"Current Phase 2 condensation mixes leaves and condensed nodes freely, producing degenerate linked-list trees. Oldest content gets re-summarized N times while newest content is summarized once. Expand cost grows linearly with conversation length.\n\nFix: only condense nodes at the same depth. Leaves merge with leaves → depth-1 nodes. Depth-1 nodes merge together → depth-2 nodes. Produces balanced trees with uniform information loss and predictable O(log N) expand cost.\n\nChanges:\n- Add depth column to summaries table (0 for leaves, max(child)+1 for condensed)\n- Replace selectOldestCondensedChunk with selectOldestChunkAtDepth\n- Phase 2 loop: shallowest eligible depth first, break on depth mismatch\n- New config: condensedMinFanout (default 4), condensedMinFanoutHard (default 2)\n- Migration: backfill depth from DAG for existing summaries\n\nSpec: specs/lcm-depth-aware-condensation.md","priority":"1","title":"LCM: depth-aware condensation to produce balanced summary trees","type":"feature"}}
{"type":"create","timestamp":"2026-02-17T23:44:31.336055Z","issue_id":"openclaw-657","payload":{"description":"Add 'depth INTEGER NOT NULL DEFAULT 0' to summaries table. Migration: all kind='leaf' get depth=0 (via DEFAULT). All kind='condensed' need DAG walk via summary_parents to compute max(parent.depth)+1. Fallback for parentless condensed: depth=1. Small graph walk, runs inline in migration. Keep kind field for backwards compat.","priority":"1","title":"Schema: add depth column to summaries table + migration backfill","type":"task"}}
{"type":"create","timestamp":"2026-02-17T23:44:36.986736Z","issue_id":"openclaw-7f8","payload":{"description":"Replace selectOldestCondensedChunk with selectOldestChunkAtDepth. Key difference: breaks on depth mismatch when chunk already started (don't mix depths). Takes targetDepth param, filters to summaries at that depth only. Also add getDistinctDepthsInContext helper (SELECT DISTINCT s.depth FROM context_items ci JOIN summaries ... ORDER BY depth ASC). Both need to respect freshTailOrdinal.","priority":"1","title":"New selection: selectOldestChunkAtDepth + getDistinctDepthsInContext","type":"task"}}
{"type":"create","timestamp":"2026-02-17T23:44:42.672947Z","issue_id":"openclaw-c52","payload":{"description":"Replace current Phase 2 condensation with depth-aware algorithm. Loop: find shallowest eligible depth (ascending scan), check fanout threshold (leafMinFanout=8 for depth 0, condensedMinFanout=4 for depth\u003e=1), select oldest chunk at that depth, condense to depth+1. Restart from shallowest after each condensation. Terminate when no eligible depth or no token reduction. Hard trigger and /compact use condensedMinFanoutHard=2 for all depths.","priority":"1","title":"Depth-aware Phase 2 loop in compactFullSweep","type":"task"}}
{"type":"create","timestamp":"2026-02-17T23:44:47.584981Z","issue_id":"openclaw-b43","payload":{"description":"Add three new LCM config parameters: leafMinFanout (default 8, min depth-0 nodes to trigger condensation), condensedMinFanout (default 4, min same-depth nodes at depth\u003e=1), condensedMinFanoutHard (default 2, relaxed minimum for hard triggers and /compact). Wire into compaction engine. Update config schema and validation.","priority":"1","title":"Config: add leafMinFanout, condensedMinFanout, condensedMinFanoutHard","type":"task"}}
{"type":"create","timestamp":"2026-02-17T23:44:52.751309Z","issue_id":"openclaw-0d8","payload":{"description":"When summarizing leaves into depth-1 nodes, include neighboring leaf content in prompt for context (existing openclaw-098 feature). When summarizing condensed nodes (depth\u003e=1) into higher-depth nodes, do NOT include neighboring node content — each condensed node is already self-sufficient. Check the summarization prompt path and gate continuity context inclusion on depth==0.","priority":"2","title":"Skip continuity context for condensed node summarization","type":"task"}}
{"type":"create","timestamp":"2026-02-17T23:44:59.149167Z","issue_id":"openclaw-355","payload":{"description":"Unit tests: depth assignment (leaves=0, condensed=max(child)+1), selectOldestChunkAtDepth only returns matching depth, depth break stops chunk on mismatch, shallowest-first processing, fanout threshold enforcement (leaf vs condensed). Integration: multiple compaction rounds produce balanced DAG, migration backfill correctness, interleaved leaf+sweep workload stays balanced, lcm_expand traverses balanced tree correctly. Regression: soft trigger unchanged, full sweep reduces below threshold, fresh tail protection.","priority":"1","title":"Tests: depth-aware condensation unit + integration","type":"task"}}
{"type":"dep_add","timestamp":"2026-02-17T23:45:03.589176Z","issue_id":"openclaw-7f8","payload":{"dep_type":"blocks","depends_on":"openclaw-657"}}
{"type":"dep_add","timestamp":"2026-02-17T23:45:03.705309Z","issue_id":"openclaw-c52","payload":{"dep_type":"blocks","depends_on":"openclaw-657"}}
{"type":"dep_add","timestamp":"2026-02-17T23:45:03.817169Z","issue_id":"openclaw-c52","payload":{"dep_type":"blocks","depends_on":"openclaw-7f8"}}
{"type":"dep_add","timestamp":"2026-02-17T23:45:03.933102Z","issue_id":"openclaw-c52","payload":{"dep_type":"blocks","depends_on":"openclaw-b43"}}
{"type":"dep_add","timestamp":"2026-02-17T23:45:04.049193Z","issue_id":"openclaw-0d8","payload":{"dep_type":"blocks","depends_on":"openclaw-c52"}}
{"type":"dep_add","timestamp":"2026-02-17T23:45:04.163473Z","issue_id":"openclaw-355","payload":{"dep_type":"blocks","depends_on":"openclaw-c52"}}
{"type":"dep_add","timestamp":"2026-02-17T23:45:04.282086Z","issue_id":"openclaw-b47","payload":{"dep_type":"blocks","depends_on":"openclaw-c52"}}
{"type":"dep_add","timestamp":"2026-02-17T23:45:04.394902Z","issue_id":"openclaw-b47","payload":{"dep_type":"blocks","depends_on":"openclaw-0d8"}}
{"type":"dep_add","timestamp":"2026-02-17T23:45:04.533377Z","issue_id":"openclaw-b47","payload":{"dep_type":"blocks","depends_on":"openclaw-355"}}
{"type":"update","timestamp":"2026-02-17T23:45:11.76951Z","issue_id":"openclaw-b47","payload":{"description":"Current Phase 2 condensation mixes leaves and condensed nodes freely, producing degenerate linked-list trees. Fix: only condense nodes at the same depth. Produces balanced trees with uniform information loss and predictable O(log N) expand cost. Spec: specs/lcm-depth-aware-condensation.md. Pagedrop: https://pagedrop.ai/g/jalehman/296e34f1740f81026845d9c2db77271f","type":"epic"}}
{"type":"status_update","timestamp":"2026-02-17T23:48:41.427861Z","issue_id":"openclaw-b47","payload":{"status":"in_progress"}}
{"type":"status_update","timestamp":"2026-02-17T23:49:16.053812Z","issue_id":"openclaw-b47","payload":{"status":"in_progress"}}
{"type":"close","timestamp":"2026-02-17T23:59:57.672081Z","issue_id":"openclaw-657","payload":{}}
{"type":"close","timestamp":"2026-02-17T23:59:57.765975Z","issue_id":"openclaw-b43","payload":{}}
{"type":"close","timestamp":"2026-02-17T23:59:57.867337Z","issue_id":"openclaw-7f8","payload":{}}
{"type":"close","timestamp":"2026-02-17T23:59:57.958292Z","issue_id":"openclaw-c52","payload":{}}
{"type":"close","timestamp":"2026-02-17T23:59:58.061403Z","issue_id":"openclaw-0d8","payload":{}}
{"type":"close","timestamp":"2026-02-17T23:59:58.158159Z","issue_id":"openclaw-355","payload":{}}
{"type":"close","timestamp":"2026-02-18T00:00:29.04642Z","issue_id":"openclaw-b47","payload":{}}
{"type":"close","timestamp":"2026-02-18T00:11:06.10298Z","issue_id":"openclaw-657","payload":{}}
{"type":"close","timestamp":"2026-02-18T00:11:06.221206Z","issue_id":"openclaw-b43","payload":{}}
{"type":"close","timestamp":"2026-02-18T00:11:06.340871Z","issue_id":"openclaw-7f8","payload":{}}
{"type":"close","timestamp":"2026-02-18T00:11:06.460407Z","issue_id":"openclaw-c52","payload":{}}
{"type":"close","timestamp":"2026-02-18T00:11:06.600802Z","issue_id":"openclaw-0d8","payload":{}}
{"type":"close","timestamp":"2026-02-18T00:11:06.718907Z","issue_id":"openclaw-355","payload":{}}
{"type":"close","timestamp":"2026-02-18T00:11:06.837825Z","issue_id":"openclaw-b47","payload":{}}
{"type":"create","timestamp":"2026-02-18T00:40:55.93215Z","issue_id":"openclaw-39e","payload":{"description":"","priority":"2","title":"Rebase josh/lcm onto main — audit conflicts and catalog plugin boundary leaks","type":"task"}}
{"type":"status_update","timestamp":"2026-02-18T00:41:53.949779Z","issue_id":"openclaw-39e","payload":{"status":"in_progress"}}
{"type":"status_update","timestamp":"2026-02-18T00:42:04.457583Z","issue_id":"openclaw-39e","payload":{"status":"in_progress"}}
{"type":"create","timestamp":"2026-02-18T01:05:47.475218Z","issue_id":"openclaw-d20","payload":{"description":"","priority":"1","title":"LCM plugin boundary cleanup — decouple core from LCM internals","type":"epic"}}
{"type":"create","timestamp":"2026-02-18T01:41:05.804502Z","issue_id":"openclaw-d2f","payload":{"description":"Two changes:\n\n1. New config incrementalMaxDepth (env: LCM_INCREMENTAL_MAX_DEPTH, default 0).\n   Controls how deep incremental compaction goes beyond leaf creation.\n   0 = leaf only (status quo), 1 = leaf + d0→d1 condensation, etc.\n   Uses normal condensedMinFanout (4), never hard fanout.\n\n2. Manual /compact should NOT use hardTrigger. Remove hardTrigger from\n   manual and threshold paths — reserved for future hard-threshold emergency.\n\nSpec: specs/lcm-incremental-condensation.md\nBranch: josh/lcm","priority":"2","title":"LCM: incremental depth-aware condensation + fix /compact fanout","type":"feature"}}
